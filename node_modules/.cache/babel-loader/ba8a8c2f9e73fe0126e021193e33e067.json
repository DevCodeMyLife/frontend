{"ast":null,"code":"(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define(\"Centrifuge\", [], factory);else if (typeof exports === 'object') exports[\"Centrifuge\"] = factory();else root[\"Centrifuge\"] = factory();\n})(this, function () {\n  return (\n    /******/\n    function () {\n      // webpackBootstrap\n\n      /******/\n      \"use strict\";\n      /******/\n\n      var __webpack_modules__ = {\n        /***/\n        382:\n        /***/\n        function _(__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.Centrifuge = void 0;\n\n          var _events = _interopRequireDefault(__webpack_require__(187));\n\n          var _subscription = _interopRequireDefault(__webpack_require__(471));\n\n          var _json = __webpack_require__(147);\n\n          var _utils = __webpack_require__(853);\n\n          function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n              \"default\": obj\n            };\n          }\n\n          function _typeof(obj) {\n            \"@babel/helpers - typeof\";\n\n            if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n              _typeof = function _typeof(obj) {\n                return typeof obj;\n              };\n            } else {\n              _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n              };\n            }\n\n            return _typeof(obj);\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n\n          function _inherits(subClass, superClass) {\n            if (typeof superClass !== \"function\" && superClass !== null) {\n              throw new TypeError(\"Super expression must either be null or a function\");\n            }\n\n            subClass.prototype = Object.create(superClass && superClass.prototype, {\n              constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true\n              }\n            });\n            if (superClass) _setPrototypeOf(subClass, superClass);\n          }\n\n          function _setPrototypeOf(o, p) {\n            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n              o.__proto__ = p;\n              return o;\n            };\n\n            return _setPrototypeOf(o, p);\n          }\n\n          function _createSuper(Derived) {\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n            return function _createSuperInternal() {\n              var Super = _getPrototypeOf(Derived),\n                  result;\n\n              if (hasNativeReflectConstruct) {\n                var NewTarget = _getPrototypeOf(this).constructor;\n\n                result = Reflect.construct(Super, arguments, NewTarget);\n              } else {\n                result = Super.apply(this, arguments);\n              }\n\n              return _possibleConstructorReturn(this, result);\n            };\n          }\n\n          function _possibleConstructorReturn(self, call) {\n            if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n              return call;\n            }\n\n            return _assertThisInitialized(self);\n          }\n\n          function _assertThisInitialized(self) {\n            if (self === void 0) {\n              throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            }\n\n            return self;\n          }\n\n          function _isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n\n            try {\n              Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n              return true;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          function _getPrototypeOf(o) {\n            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n              return o.__proto__ || Object.getPrototypeOf(o);\n            };\n            return _getPrototypeOf(o);\n          }\n\n          var _errorTimeout = 'timeout';\n          var _errorConnectionClosed = 'connection closed';\n\n          var Centrifuge = /*#__PURE__*/function (_EventEmitter) {\n            _inherits(Centrifuge, _EventEmitter);\n\n            var _super = _createSuper(Centrifuge);\n\n            function Centrifuge(url, options) {\n              var _this;\n\n              _classCallCheck(this, Centrifuge);\n\n              _this = _super.call(this);\n              _this._url = url;\n              _this._websocket = null;\n              _this._sockjs = null;\n              _this._isSockjs = false;\n              _this._xmlhttprequest = null;\n              _this._binary = false;\n              _this._methodType = null;\n              _this._pushType = null;\n              _this._encoder = null;\n              _this._decoder = null;\n              _this._status = 'disconnected';\n              _this._reconnect = true;\n              _this._reconnecting = false;\n              _this._transport = null;\n              _this._transportName = null;\n              _this._transportClosed = true;\n              _this._messageId = 0;\n              _this._clientID = null;\n              _this._refreshRequired = false;\n              _this._subs = {};\n              _this._serverSubs = {};\n              _this._lastSeq = {};\n              _this._lastGen = {};\n              _this._lastOffset = {};\n              _this._lastEpoch = {};\n              _this._messages = [];\n              _this._isBatching = false;\n              _this._isSubscribeBatching = false;\n              _this._privateChannels = {};\n              _this._numRefreshFailed = 0;\n              _this._refreshTimeout = null;\n              _this._pingTimeout = null;\n              _this._pongTimeout = null;\n              _this._subRefreshTimeouts = {};\n              _this._retries = 0;\n              _this._callbacks = {};\n              _this._latency = null;\n              _this._latencyStart = null;\n              _this._connectData = null;\n              _this._token = null;\n              _this._xhrID = 0;\n              _this._xhrs = {};\n              _this._dispatchPromise = Promise.resolve();\n              _this._config = {\n                debug: false,\n                name: '',\n                version: '',\n                websocket: null,\n                sockjs: null,\n                xmlhttprequest: null,\n                minRetry: 1000,\n                maxRetry: 20000,\n                timeout: 5000,\n                ping: true,\n                pingInterval: 25000,\n                pongWaitTimeout: 5000,\n                privateChannelPrefix: '$',\n                onTransportClose: null,\n                sockjsServer: null,\n                sockjsTransports: ['websocket', 'xdr-streaming', 'xhr-streaming', 'eventsource', 'iframe-eventsource', 'iframe-htmlfile', 'xdr-polling', 'xhr-polling', 'iframe-xhr-polling', 'jsonp-polling'],\n                refreshEndpoint: '/centrifuge/refresh',\n                refreshHeaders: {},\n                refreshParams: {},\n                refreshData: {},\n                refreshAttempts: null,\n                refreshInterval: 1000,\n                onRefreshFailed: null,\n                onRefresh: null,\n                subscribeEndpoint: '/centrifuge/subscribe',\n                subscribeHeaders: {},\n                subscribeParams: {},\n                subRefreshInterval: 1000,\n                onPrivateSubscribe: null\n              };\n\n              _this._configure(options);\n\n              return _this;\n            }\n\n            _createClass(Centrifuge, [{\n              key: \"setToken\",\n              value: function setToken(token) {\n                this._token = token;\n              }\n            }, {\n              key: \"setConnectData\",\n              value: function setConnectData(data) {\n                this._connectData = data;\n              }\n            }, {\n              key: \"setRefreshHeaders\",\n              value: function setRefreshHeaders(headers) {\n                this._config.refreshHeaders = headers;\n              }\n            }, {\n              key: \"setRefreshParams\",\n              value: function setRefreshParams(params) {\n                this._config.refreshParams = params;\n              }\n            }, {\n              key: \"setRefreshData\",\n              value: function setRefreshData(data) {\n                this._config.refreshData = data;\n              }\n            }, {\n              key: \"setSubscribeHeaders\",\n              value: function setSubscribeHeaders(headers) {\n                this._config.subscribeHeaders = headers;\n              }\n            }, {\n              key: \"setSubscribeParams\",\n              value: function setSubscribeParams(params) {\n                this._config.subscribeParams = params;\n              }\n            }, {\n              key: \"_ajax\",\n              value: function _ajax(url, params, headers, data, callback) {\n                var _this2 = this;\n\n                var query = '';\n\n                this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n                var xhr;\n\n                if (this._xmlhttprequest !== null) {\n                  // use explicitly passed XMLHttpRequest object.\n                  xhr = new this._xmlhttprequest();\n                } else {\n                  xhr = __webpack_require__.g.XMLHttpRequest ? new __webpack_require__.g.XMLHttpRequest() : new __webpack_require__.g.ActiveXObject('Microsoft.XMLHTTP');\n                }\n\n                for (var i in params) {\n                  if (params.hasOwnProperty(i)) {\n                    if (query.length > 0) {\n                      query += '&';\n                    }\n\n                    query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n                  }\n                }\n\n                if (query.length > 0) {\n                  query = '?' + query;\n                }\n\n                xhr.open('POST', url + query, true);\n\n                if ('withCredentials' in xhr) {\n                  xhr.withCredentials = true;\n                }\n\n                xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n                xhr.setRequestHeader('Content-Type', 'application/json');\n\n                for (var headerName in headers) {\n                  if (headers.hasOwnProperty(headerName)) {\n                    xhr.setRequestHeader(headerName, headers[headerName]);\n                  }\n                }\n\n                xhr.onreadystatechange = function () {\n                  if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                      var _data,\n                          parsed = false;\n\n                      try {\n                        _data = JSON.parse(xhr.responseText);\n                        parsed = true;\n                      } catch (e) {\n                        callback({\n                          error: 'Invalid JSON. Data was: ' + xhr.responseText,\n                          status: 200,\n                          data: null\n                        });\n                      }\n\n                      if (parsed) {\n                        // prevents double execution.\n                        callback({\n                          data: _data,\n                          status: 200\n                        });\n                      }\n                    } else {\n                      _this2._log('wrong status code in AJAX response', xhr.status);\n\n                      callback({\n                        status: xhr.status,\n                        data: null\n                      });\n                    }\n                  }\n                };\n\n                setTimeout(function () {\n                  return xhr.send(JSON.stringify(data));\n                }, 20);\n                return xhr;\n              }\n            }, {\n              key: \"_log\",\n              value: function _log() {\n                (0, _utils.log)('info', arguments);\n              }\n            }, {\n              key: \"_debug\",\n              value: function _debug() {\n                if (this._config.debug === true) {\n                  (0, _utils.log)('debug', arguments);\n                }\n              }\n            }, {\n              key: \"_websocketSupported\",\n              value: function _websocketSupported() {\n                if (this._config.websocket !== null) {\n                  return true;\n                }\n\n                return !(typeof WebSocket !== 'function' && (typeof WebSocket === \"undefined\" ? \"undefined\" : _typeof(WebSocket)) !== 'object');\n              }\n            }, {\n              key: \"_setFormat\",\n              value: function _setFormat(format) {\n                if (this._formatOverride(format)) {\n                  return;\n                }\n\n                if (format === 'protobuf') {\n                  throw new Error('not implemented by JSON only Centrifuge client â€“ use client with Protobuf');\n                }\n\n                this._binary = false;\n                this._methodType = _json.JsonMethodType;\n                this._pushType = _json.JsonPushType;\n                this._encoder = new _json.JsonEncoder();\n                this._decoder = new _json.JsonDecoder();\n              }\n            }, {\n              key: \"_formatOverride\",\n              value: function _formatOverride(format) {\n                return false;\n              }\n            }, {\n              key: \"_configure\",\n              value: function _configure(configuration) {\n                if (!('Promise' in __webpack_require__.g)) {\n                  throw new Error('Promise polyfill required');\n                }\n\n                (0, _utils.extend)(this._config, configuration || {});\n\n                this._debug('centrifuge config', this._config);\n\n                if (!this._url) {\n                  throw new Error('url required');\n                }\n\n                if ((0, _utils.startsWith)(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n                  this._setFormat('protobuf');\n                } else {\n                  this._setFormat('json');\n                }\n\n                if ((0, _utils.startsWith)(this._url, 'http')) {\n                  this._debug('client will try to connect to SockJS endpoint');\n\n                  if (this._config.sockjs !== null) {\n                    this._debug('SockJS explicitly provided in options');\n\n                    this._sockjs = this._config.sockjs;\n                  } else {\n                    if (typeof __webpack_require__.g.SockJS === 'undefined') {\n                      throw new Error('SockJS not found, use ws:// in url or include SockJS');\n                    }\n\n                    this._debug('use globally defined SockJS');\n\n                    this._sockjs = __webpack_require__.g.SockJS;\n                  }\n                } else {\n                  this._debug('client will connect to websocket endpoint');\n                }\n\n                this._xmlhttprequest = this._config.xmlhttprequest;\n              }\n            }, {\n              key: \"_setStatus\",\n              value: function _setStatus(newStatus) {\n                if (this._status !== newStatus) {\n                  this._debug('Status', this._status, '->', newStatus);\n\n                  this._status = newStatus;\n                }\n              }\n            }, {\n              key: \"_isDisconnected\",\n              value: function _isDisconnected() {\n                return this._status === 'disconnected';\n              }\n            }, {\n              key: \"_isConnecting\",\n              value: function _isConnecting() {\n                return this._status === 'connecting';\n              }\n            }, {\n              key: \"_isConnected\",\n              value: function _isConnected() {\n                return this._status === 'connected';\n              }\n            }, {\n              key: \"_nextMessageId\",\n              value: function _nextMessageId() {\n                return ++this._messageId;\n              }\n            }, {\n              key: \"_resetRetry\",\n              value: function _resetRetry() {\n                this._debug('reset retries count to 0');\n\n                this._retries = 0;\n              }\n            }, {\n              key: \"_getRetryInterval\",\n              value: function _getRetryInterval() {\n                var interval = (0, _utils.backoff)(this._retries, this._config.minRetry, this._config.maxRetry);\n                this._retries += 1;\n                return interval;\n              }\n            }, {\n              key: \"_abortInflightXHRs\",\n              value: function _abortInflightXHRs() {\n                for (var xhrID in this._xhrs) {\n                  try {\n                    this._xhrs[xhrID].abort();\n                  } catch (e) {\n                    this._debug('error aborting xhr', e);\n                  }\n\n                  delete this._xhrs[xhrID];\n                }\n              }\n            }, {\n              key: \"_clearConnectedState\",\n              value: function _clearConnectedState(reconnect) {\n                this._clientID = null;\n\n                this._stopPing(); // fire errbacks of registered outgoing calls.\n\n\n                for (var id in this._callbacks) {\n                  if (this._callbacks.hasOwnProperty(id)) {\n                    var callbacks = this._callbacks[id];\n                    clearTimeout(callbacks.timeout);\n                    var errback = callbacks.errback;\n\n                    if (!errback) {\n                      continue;\n                    }\n\n                    errback({\n                      error: this._createErrorObject('disconnected')\n                    });\n                  }\n                }\n\n                this._callbacks = {}; // fire unsubscribe events\n\n                for (var channel in this._subs) {\n                  if (this._subs.hasOwnProperty(channel)) {\n                    var sub = this._subs[channel];\n\n                    if (reconnect) {\n                      if (sub._isSuccess()) {\n                        sub._triggerUnsubscribe();\n\n                        sub._recover = true;\n                      }\n\n                      if (sub._shouldResubscribe()) {\n                        sub._setSubscribing();\n                      }\n                    } else {\n                      sub._setUnsubscribed();\n                    }\n                  }\n                }\n\n                this._abortInflightXHRs(); // clear refresh timer\n\n\n                if (this._refreshTimeout !== null) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                } // clear sub refresh timers\n\n\n                for (var _channel in this._subRefreshTimeouts) {\n                  if (this._subRefreshTimeouts.hasOwnProperty(_channel) && this._subRefreshTimeouts[_channel]) {\n                    this._clearSubRefreshTimeout(_channel);\n                  }\n                }\n\n                this._subRefreshTimeouts = {};\n\n                if (!this._reconnect) {\n                  // completely clear subscriptions\n                  this._subs = {};\n                }\n              }\n            }, {\n              key: \"_isTransportOpen\",\n              value: function _isTransportOpen() {\n                if (this._isSockjs) {\n                  return this._transport && this._transport.transport && this._transport.transport.readyState === this._transport.transport.OPEN;\n                }\n\n                return this._transport && this._transport.readyState === this._transport.OPEN;\n              }\n            }, {\n              key: \"_transportSend\",\n              value: function _transportSend(commands) {\n                if (!commands.length) {\n                  return true;\n                }\n\n                if (!this._isTransportOpen()) {\n                  // resolve pending commands with error if transport is not open\n                  for (var command in commands) {\n                    var id = command.id;\n\n                    if (!(id in this._callbacks)) {\n                      continue;\n                    }\n\n                    var callbacks = this._callbacks[id];\n                    clearTimeout(this._callbacks[id].timeout);\n                    delete this._callbacks[id];\n                    var errback = callbacks.errback;\n                    errback({\n                      error: this._createErrorObject(_errorConnectionClosed, 0)\n                    });\n                  }\n\n                  return false;\n                }\n\n                this._transport.send(this._encoder.encodeCommands(commands));\n\n                return true;\n              }\n            }, {\n              key: \"_setupTransport\",\n              value: function _setupTransport() {\n                var _this3 = this;\n\n                this._isSockjs = false; // detect transport to use - SockJS or Websocket\n\n                if (this._sockjs !== null) {\n                  var sockjsOptions = {\n                    transports: this._config.sockjsTransports\n                  };\n\n                  if (this._config.sockjsServer !== null) {\n                    sockjsOptions.server = this._config.sockjsServer;\n                  }\n\n                  this._isSockjs = true;\n                  this._transport = new this._sockjs(this._url, null, sockjsOptions);\n                } else {\n                  if (!this._websocketSupported()) {\n                    this._debug('No Websocket support and no SockJS configured, can not connect');\n\n                    return;\n                  }\n\n                  if (this._config.websocket !== null) {\n                    this._websocket = this._config.websocket;\n                  } else {\n                    this._websocket = WebSocket;\n                  }\n\n                  this._transport = new this._websocket(this._url);\n\n                  if (this._binary === true) {\n                    this._transport.binaryType = 'arraybuffer';\n                  }\n                }\n\n                this._transport.onopen = function () {\n                  _this3._transportClosed = false;\n\n                  if (_this3._isSockjs) {\n                    _this3._transportName = 'sockjs-' + _this3._transport.transport;\n\n                    _this3._transport.onheartbeat = function () {\n                      return _this3._restartPing();\n                    };\n                  } else {\n                    _this3._transportName = 'websocket';\n                  } // Can omit method here due to zero value.\n\n\n                  var msg = {// method: this._methodType.CONNECT\n                  };\n\n                  if (_this3._token || _this3._connectData || _this3._config.name || _this3._config.version) {\n                    msg.params = {};\n                  }\n\n                  if (_this3._token) {\n                    msg.params.token = _this3._token;\n                  }\n\n                  if (_this3._connectData) {\n                    msg.params.data = _this3._connectData;\n                  }\n\n                  if (_this3._config.name) {\n                    msg.params.name = _this3._config.name;\n                  }\n\n                  if (_this3._config.version) {\n                    msg.params.version = _this3._config.version;\n                  }\n\n                  var subs = {};\n                  var hasSubs = false;\n\n                  for (var channel in _this3._serverSubs) {\n                    if (_this3._serverSubs.hasOwnProperty(channel) && _this3._serverSubs[channel].recoverable) {\n                      hasSubs = true;\n                      var sub = {\n                        'recover': true\n                      };\n\n                      if (_this3._serverSubs[channel].seq || _this3._serverSubs[channel].gen) {\n                        if (_this3._serverSubs[channel].seq) {\n                          sub['seq'] = _this3._serverSubs[channel].seq;\n                        }\n\n                        if (_this3._serverSubs[channel].gen) {\n                          sub['gen'] = _this3._serverSubs[channel].gen;\n                        }\n                      } else {\n                        if (_this3._serverSubs[channel].offset) {\n                          sub['offset'] = _this3._serverSubs[channel].offset;\n                        }\n                      }\n\n                      if (_this3._serverSubs[channel].epoch) {\n                        sub['epoch'] = _this3._serverSubs[channel].epoch;\n                      }\n\n                      subs[channel] = sub;\n                    }\n                  }\n\n                  if (hasSubs) {\n                    if (!msg.params) {\n                      msg.params = {};\n                    }\n\n                    msg.params.subs = subs;\n                  }\n\n                  _this3._latencyStart = new Date();\n\n                  _this3._call(msg).then(function (resolveCtx) {\n                    _this3._connectResponse(_this3._decoder.decodeCommandResult(_this3._methodType.CONNECT, resolveCtx.result), hasSubs);\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    var err = rejectCtx.error;\n\n                    if (err.code === 109) {\n                      // token expired.\n                      _this3._refreshRequired = true;\n                    }\n\n                    _this3._disconnect('connect error', true);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                };\n\n                this._transport.onerror = function (error) {\n                  _this3._debug('transport level error', error);\n                };\n\n                this._transport.onclose = function (closeEvent) {\n                  _this3._transportClosed = true;\n                  var reason = _errorConnectionClosed;\n                  var needReconnect = true;\n\n                  if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n                    try {\n                      var advice = JSON.parse(closeEvent.reason);\n\n                      _this3._debug('reason is an advice object', advice);\n\n                      reason = advice.reason;\n                      needReconnect = advice.reconnect;\n                    } catch (e) {\n                      reason = closeEvent.reason;\n\n                      _this3._debug('reason is a plain string', reason);\n                    }\n                  } // onTransportClose callback should be executed every time transport was closed.\n                  // This can be helpful to catch failed connection events (because our disconnect\n                  // event only called once and every future attempts to connect do not fire disconnect\n                  // event again).\n\n\n                  if (_this3._config.onTransportClose !== null) {\n                    _this3._config.onTransportClose({\n                      event: closeEvent,\n                      reason: reason,\n                      reconnect: needReconnect\n                    });\n                  }\n\n                  _this3._disconnect(reason, needReconnect);\n\n                  if (_this3._reconnect === true) {\n                    _this3._reconnecting = true;\n\n                    var interval = _this3._getRetryInterval();\n\n                    _this3._debug('reconnect after ' + interval + ' milliseconds');\n\n                    setTimeout(function () {\n                      if (_this3._reconnect === true) {\n                        if (_this3._refreshRequired) {\n                          _this3._refresh();\n                        } else {\n                          _this3._connect();\n                        }\n                      }\n                    }, interval);\n                  }\n                };\n\n                this._transport.onmessage = function (event) {\n                  _this3._dataReceived(event.data);\n                };\n              }\n            }, {\n              key: \"rpc\",\n              value: function rpc(data) {\n                return this._rpc('', data);\n              }\n            }, {\n              key: \"namedRPC\",\n              value: function namedRPC(method, data) {\n                return this._rpc(method, data);\n              }\n            }, {\n              key: \"_rpc\",\n              value: function _rpc(method, data) {\n                var params = {\n                  data: data\n                };\n\n                if (method !== '') {\n                  params.method = method;\n                }\n\n                ;\n                var msg = {\n                  method: this._methodType.RPC,\n                  params: params\n                };\n                return this._methodCall(msg, function (result) {\n                  return result;\n                });\n              }\n            }, {\n              key: \"send\",\n              value: function send(data) {\n                var msg = {\n                  method: this._methodType.SEND,\n                  params: {\n                    data: data\n                  }\n                };\n\n                if (!this.isConnected()) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                var sent = this._transportSend([msg]); // can send async message to server without id set\n\n\n                if (!sent) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                ;\n                return Promise.resolve({});\n              }\n            }, {\n              key: \"_getHistoryParams\",\n              value: function _getHistoryParams(channel, options) {\n                var params = {\n                  channel: channel\n                };\n\n                if (options !== undefined) {\n                  if (options.since) {\n                    params['use_since'] = true;\n\n                    if (options.since.offset) {\n                      params['offset'] = options.since.offset;\n                    }\n\n                    if (options.since.epoch) {\n                      params['epoch'] = options.since.epoch;\n                    }\n                  }\n\n                  ;\n\n                  if (options.limit !== undefined) {\n                    params['use_limit'] = true;\n                    params['limit'] = options.limit;\n                  }\n                }\n\n                ;\n                return params;\n              }\n            }, {\n              key: \"_methodCall\",\n              value: function _methodCall(msg, resultCB) {\n                var _this4 = this;\n\n                if (!this.isConnected()) {\n                  return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n                }\n\n                return new Promise(function (resolve, reject) {\n                  _this4._call(msg).then(function (resolveCtx) {\n                    resolve(resultCB(_this4._decoder.decodeCommandResult(msg.method, resolveCtx.result)));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    reject(rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                });\n              }\n            }, {\n              key: \"publish\",\n              value: function publish(channel, data) {\n                var msg = {\n                  method: this._methodType.PUBLISH,\n                  params: {\n                    channel: channel,\n                    data: data\n                  }\n                };\n                return this._methodCall(msg, function () {\n                  return {};\n                });\n              }\n            }, {\n              key: \"history\",\n              value: function history(channel, options) {\n                var params = this._getHistoryParams(channel, options);\n\n                var msg = {\n                  method: this._methodType.HISTORY,\n                  params: params\n                };\n                return this._methodCall(msg, function (result) {\n                  return {\n                    'publications': result.publications,\n                    'epoch': result.epoch || '',\n                    'offset': result.offset || 0\n                  };\n                });\n              }\n            }, {\n              key: \"presence\",\n              value: function presence(channel) {\n                var msg = {\n                  method: this._methodType.PRESENCE,\n                  params: {\n                    channel: channel\n                  }\n                };\n                return this._methodCall(msg, function (result) {\n                  return {\n                    'presence': result.presence\n                  };\n                });\n              }\n            }, {\n              key: \"presenceStats\",\n              value: function presenceStats(channel) {\n                var msg = {\n                  method: this._methodType.PRESENCE_STATS,\n                  params: {\n                    channel: channel\n                  }\n                };\n                return this._methodCall(msg, function (result) {\n                  return {\n                    'num_users': result.num_users,\n                    'num_clients': result.num_clients\n                  };\n                });\n              }\n            }, {\n              key: \"_dataReceived\",\n              value: function _dataReceived(data) {\n                var _this5 = this;\n\n                var replies = this._decoder.decodeReplies(data); // we have to guarantee order of events in replies processing - i.e. start processing\n                // next reply only when we finished processing of current one. Without syncing things in\n                // this way we could get wrong publication events order as reply promises resolve\n                // on next loop tick so for loop continues before we finished emitting all reply events.\n\n\n                this._dispatchPromise = this._dispatchPromise.then(function () {\n                  var finishDispatch;\n                  _this5._dispatchPromise = new Promise(function (resolve) {\n                    finishDispatch = resolve;\n                  });\n\n                  _this5._dispatchSynchronized(replies, finishDispatch);\n                });\n\n                this._restartPing();\n              }\n            }, {\n              key: \"_dispatchSynchronized\",\n              value: function _dispatchSynchronized(replies, finishDispatch) {\n                var _this6 = this;\n\n                var p = Promise.resolve();\n\n                var _loop = function _loop(i) {\n                  if (replies.hasOwnProperty(i)) {\n                    p = p.then(function () {\n                      return _this6._dispatchReply(replies[i]);\n                    });\n                  }\n                };\n\n                for (var i in replies) {\n                  _loop(i);\n                }\n\n                p = p.then(function () {\n                  finishDispatch();\n                });\n              }\n            }, {\n              key: \"_dispatchReply\",\n              value: function _dispatchReply(reply) {\n                var next;\n                var p = new Promise(function (resolve) {\n                  next = resolve;\n                });\n\n                if (reply === undefined || reply === null) {\n                  this._debug('dispatch: got undefined or null reply');\n\n                  next();\n                  return p;\n                }\n\n                var id = reply.id;\n\n                if (id && id > 0) {\n                  this._handleReply(reply, next);\n                } else {\n                  this._handlePush(reply.result, next);\n                }\n\n                return p;\n              }\n            }, {\n              key: \"_call\",\n              value: function _call(msg) {\n                var _this7 = this;\n\n                return new Promise(function (resolve, reject) {\n                  var id = _this7._addMessage(msg);\n\n                  _this7._registerCall(id, resolve, reject);\n                });\n              }\n            }, {\n              key: \"_connect\",\n              value: function _connect() {\n                if (this.isConnected()) {\n                  this._debug('connect called when already connected');\n\n                  return;\n                }\n\n                if (this._status === 'connecting') {\n                  return;\n                }\n\n                this._debug('start connecting');\n\n                this._setStatus('connecting');\n\n                this._clientID = null;\n                this._reconnect = true;\n\n                this._setupTransport();\n              }\n            }, {\n              key: \"_disconnect\",\n              value: function _disconnect(reason, shouldReconnect) {\n                var reconnect = shouldReconnect || false;\n\n                if (reconnect === false) {\n                  this._reconnect = false;\n                }\n\n                if (this._isDisconnected()) {\n                  if (!reconnect) {\n                    this._clearConnectedState(reconnect);\n                  }\n\n                  return;\n                }\n\n                this._clearConnectedState(reconnect);\n\n                this._debug('disconnected:', reason, shouldReconnect);\n\n                this._setStatus('disconnected');\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                if (this._reconnecting === false) {\n                  // fire unsubscribe events for server side subs.\n                  for (var channel in this._serverSubs) {\n                    if (this._serverSubs.hasOwnProperty(channel)) {\n                      this.emit('unsubscribe', {\n                        channel: channel\n                      });\n                    }\n                  }\n\n                  this.emit('disconnect', {\n                    reason: reason,\n                    reconnect: reconnect\n                  });\n                }\n\n                if (reconnect === false) {\n                  this._subs = {};\n                  this._serverSubs = {};\n                }\n\n                if (!this._transportClosed) {\n                  this._transport.close();\n                }\n              }\n            }, {\n              key: \"_refreshFailed\",\n              value: function _refreshFailed() {\n                this._numRefreshFailed = 0;\n\n                if (!this._isDisconnected()) {\n                  this._disconnect('refresh failed', false);\n                }\n\n                if (this._config.onRefreshFailed !== null) {\n                  this._config.onRefreshFailed();\n                }\n              }\n            }, {\n              key: \"_refresh\",\n              value: function _refresh() {\n                var _this8 = this; // ask application for new connection token.\n\n\n                this._debug('refresh token');\n\n                if (this._config.refreshAttempts === 0) {\n                  this._debug('refresh attempts set to 0, do not send refresh request at all');\n\n                  this._refreshFailed();\n\n                  return;\n                }\n\n                if (this._refreshTimeout !== null) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this8._xhrs) {\n                    delete _this8._xhrs[xhrID];\n                  }\n\n                  if (_this8._clientID !== clientID) {\n                    return;\n                  }\n\n                  if (resp.error || resp.status !== 200) {\n                    // We don't perform any connection status related actions here as we are\n                    // relying on server that must close connection eventually.\n                    if (resp.error) {\n                      _this8._debug('error refreshing connection token', resp.error);\n                    } else {\n                      _this8._debug('error refreshing connection token: wrong status code', resp.status);\n                    }\n\n                    _this8._numRefreshFailed++;\n\n                    if (_this8._refreshTimeout !== null) {\n                      clearTimeout(_this8._refreshTimeout);\n                      _this8._refreshTimeout = null;\n                    }\n\n                    if (_this8._config.refreshAttempts !== null && _this8._numRefreshFailed >= _this8._config.refreshAttempts) {\n                      _this8._refreshFailed();\n\n                      return;\n                    }\n\n                    var jitter = Math.round(Math.random() * 1000 * Math.max(_this8._numRefreshFailed, 20));\n                    var interval = _this8._config.refreshInterval + jitter;\n                    _this8._refreshTimeout = setTimeout(function () {\n                      return _this8._refresh();\n                    }, interval);\n                    return;\n                  }\n\n                  _this8._numRefreshFailed = 0;\n                  _this8._token = resp.data.token;\n\n                  if (!_this8._token) {\n                    _this8._refreshFailed();\n\n                    return;\n                  }\n\n                  if (_this8._isDisconnected() && _this8._reconnect) {\n                    _this8._debug('token refreshed, connect from scratch');\n\n                    _this8._connect();\n                  } else {\n                    _this8._debug('send refreshed token');\n\n                    var msg = {\n                      method: _this8._methodType.REFRESH,\n                      params: {\n                        token: _this8._token\n                      }\n                    };\n\n                    _this8._call(msg).then(function (resolveCtx) {\n                      _this8._refreshResponse(_this8._decoder.decodeCommandResult(_this8._methodType.REFRESH, resolveCtx.result));\n\n                      if (resolveCtx.next) {\n                        resolveCtx.next();\n                      }\n                    }, function (rejectCtx) {\n                      _this8._refreshError(rejectCtx.error);\n\n                      if (rejectCtx.next) {\n                        rejectCtx.next();\n                      }\n                    });\n                  }\n                };\n\n                if (this._config.onRefresh !== null) {\n                  var context = {};\n\n                  this._config.onRefresh(context, cb);\n                } else {\n                  var xhr = this._ajax(this._config.refreshEndpoint, this._config.refreshParams, this._config.refreshHeaders, this._config.refreshData, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: \"_refreshError\",\n              value: function _refreshError(err) {\n                var _this9 = this;\n\n                this._debug('refresh error', err);\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                var interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n                this._refreshTimeout = setTimeout(function () {\n                  return _this9._refresh();\n                }, interval);\n              }\n            }, {\n              key: \"_refreshResponse\",\n              value: function _refreshResponse(result) {\n                var _this10 = this;\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                  this._refreshTimeout = null;\n                }\n\n                if (result.expires) {\n                  this._clientID = result.client;\n                  this._refreshTimeout = setTimeout(function () {\n                    return _this10._refresh();\n                  }, this._getTTLMilliseconds(result.ttl));\n                }\n              }\n            }, {\n              key: \"_newXHRID\",\n              value: function _newXHRID() {\n                this._xhrID++;\n                return this._xhrID;\n              }\n            }, {\n              key: \"_subRefresh\",\n              value: function _subRefresh(channel) {\n                var _this11 = this;\n\n                this._debug('refresh subscription token for channel', channel);\n\n                if (this._subRefreshTimeouts[channel] !== undefined) {\n                  this._clearSubRefreshTimeout(channel);\n                } else {\n                  return;\n                }\n\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this11._xhrs) {\n                    delete _this11._xhrs[xhrID];\n                  }\n\n                  if (resp.error || resp.status !== 200 || _this11._clientID !== clientID) {\n                    return;\n                  }\n\n                  var channelsData = {};\n\n                  if (resp.data.channels) {\n                    for (var i in resp.data.channels) {\n                      var channelData = resp.data.channels[i];\n\n                      if (!channelData.channel) {\n                        continue;\n                      }\n\n                      channelsData[channelData.channel] = channelData.token;\n                    }\n                  }\n\n                  var token = channelsData[channel];\n\n                  if (!token) {\n                    return;\n                  }\n\n                  var msg = {\n                    method: _this11._methodType.SUB_REFRESH,\n                    params: {\n                      channel: channel,\n                      token: token\n                    }\n                  };\n\n                  var sub = _this11._getSub(channel);\n\n                  if (sub === null) {\n                    return;\n                  }\n\n                  _this11._call(msg).then(function (resolveCtx) {\n                    _this11._subRefreshResponse(channel, _this11._decoder.decodeCommandResult(_this11._methodType.SUB_REFRESH, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    _this11._subRefreshError(channel, rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                };\n\n                var data = {\n                  client: this._clientID,\n                  channels: [channel]\n                };\n\n                if (this._config.onPrivateSubscribe !== null) {\n                  this._config.onPrivateSubscribe({\n                    data: data\n                  }, cb);\n                } else {\n                  var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: \"_clearSubRefreshTimeout\",\n              value: function _clearSubRefreshTimeout(channel) {\n                if (this._subRefreshTimeouts[channel] !== undefined) {\n                  clearTimeout(this._subRefreshTimeouts[channel]);\n                  delete this._subRefreshTimeouts[channel];\n                }\n              }\n            }, {\n              key: \"_subRefreshError\",\n              value: function _subRefreshError(channel, err) {\n                var _this12 = this;\n\n                this._debug('subscription refresh error', channel, err);\n\n                this._clearSubRefreshTimeout(channel);\n\n                var sub = this._getSub(channel);\n\n                if (sub === null) {\n                  return;\n                }\n\n                var jitter = Math.round(Math.random() * 1000);\n                var subRefreshTimeout = setTimeout(function () {\n                  return _this12._subRefresh(channel);\n                }, this._config.subRefreshInterval + jitter);\n                this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                return;\n              }\n            }, {\n              key: \"_subRefreshResponse\",\n              value: function _subRefreshResponse(channel, result) {\n                var _this13 = this;\n\n                this._debug('subscription refresh success', channel);\n\n                this._clearSubRefreshTimeout(channel);\n\n                var sub = this._getSub(channel);\n\n                if (sub === null) {\n                  return;\n                }\n\n                if (result.expires === true) {\n                  var subRefreshTimeout = setTimeout(function () {\n                    return _this13._subRefresh(channel);\n                  }, this._getTTLMilliseconds(result.ttl));\n                  this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                }\n\n                return;\n              }\n            }, {\n              key: \"_subscribe\",\n              value: function _subscribe(sub, isResubscribe) {\n                var _this14 = this;\n\n                this._debug('subscribing on', sub.channel);\n\n                var channel = sub.channel;\n\n                if (!(channel in this._subs)) {\n                  this._subs[channel] = sub;\n                }\n\n                if (!this.isConnected()) {\n                  // subscribe will be called later\n                  sub._setNew();\n\n                  return;\n                }\n\n                sub._setSubscribing(isResubscribe);\n\n                var msg = {\n                  method: this._methodType.SUBSCRIBE,\n                  params: {\n                    channel: channel\n                  }\n                }; // If channel name does not start with privateChannelPrefix - then we\n                // can just send subscription message to Centrifuge. If channel name\n                // starts with privateChannelPrefix - then this is a private channel\n                // and we should ask web application backend for permission first.\n\n                if ((0, _utils.startsWith)(channel, this._config.privateChannelPrefix)) {\n                  // private channel.\n                  if (this._isSubscribeBatching) {\n                    this._privateChannels[channel] = true;\n                  } else {\n                    this.startSubscribeBatching();\n\n                    this._subscribe(sub);\n\n                    this.stopSubscribeBatching();\n                  }\n                } else {\n                  var recover = sub._needRecover();\n\n                  if (recover === true) {\n                    msg.params.recover = true;\n\n                    var seq = this._getLastSeq(channel);\n\n                    var gen = this._getLastGen(channel);\n\n                    if (seq || gen) {\n                      if (seq) {\n                        msg.params.seq = seq;\n                      }\n\n                      if (gen) {\n                        msg.params.gen = gen;\n                      }\n                    } else {\n                      var offset = this._getLastOffset(channel);\n\n                      if (offset) {\n                        msg.params.offset = offset;\n                      }\n                    }\n\n                    var epoch = this._getLastEpoch(channel);\n\n                    if (epoch) {\n                      msg.params.epoch = epoch;\n                    }\n                  }\n\n                  this._call(msg).then(function (resolveCtx) {\n                    _this14._subscribeResponse(channel, recover, _this14._decoder.decodeCommandResult(_this14._methodType.SUBSCRIBE, resolveCtx.result));\n\n                    if (resolveCtx.next) {\n                      resolveCtx.next();\n                    }\n                  }, function (rejectCtx) {\n                    _this14._subscribeError(channel, rejectCtx.error);\n\n                    if (rejectCtx.next) {\n                      rejectCtx.next();\n                    }\n                  });\n                }\n              }\n            }, {\n              key: \"_unsubscribe\",\n              value: function _unsubscribe(sub) {\n                delete this._subs[sub.channel];\n                delete this._lastOffset[sub.channel];\n                delete this._lastSeq[sub.channel];\n                delete this._lastGen[sub.channel];\n\n                if (this.isConnected()) {\n                  // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n                  this._addMessage({\n                    method: this._methodType.UNSUBSCRIBE,\n                    params: {\n                      channel: sub.channel\n                    }\n                  });\n                }\n              }\n            }, {\n              key: \"_getTTLMilliseconds\",\n              value: function _getTTLMilliseconds(ttl) {\n                // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n                return Math.min(ttl * 1000, 2147483647);\n              }\n            }, {\n              key: \"getSub\",\n              value: function getSub(channel) {\n                return this._getSub(channel);\n              }\n            }, {\n              key: \"_getSub\",\n              value: function _getSub(channel) {\n                var sub = this._subs[channel];\n\n                if (!sub) {\n                  return null;\n                }\n\n                return sub;\n              }\n            }, {\n              key: \"_isServerSub\",\n              value: function _isServerSub(channel) {\n                return this._serverSubs[channel] !== undefined;\n              }\n            }, {\n              key: \"_connectResponse\",\n              value: function _connectResponse(result, isRecover) {\n                var _this15 = this;\n\n                var wasReconnecting = this._reconnecting;\n                this._reconnecting = false;\n\n                this._resetRetry();\n\n                this._refreshRequired = false;\n\n                if (this.isConnected()) {\n                  return;\n                }\n\n                if (this._latencyStart !== null) {\n                  this._latency = new Date().getTime() - this._latencyStart.getTime();\n                  this._latencyStart = null;\n                }\n\n                this._clientID = result.client;\n\n                this._setStatus('connected');\n\n                if (this._refreshTimeout) {\n                  clearTimeout(this._refreshTimeout);\n                }\n\n                if (result.expires) {\n                  this._refreshTimeout = setTimeout(function () {\n                    return _this15._refresh();\n                  }, this._getTTLMilliseconds(result.ttl));\n                }\n\n                this.startBatching();\n                this.startSubscribeBatching();\n\n                for (var channel in this._subs) {\n                  if (this._subs.hasOwnProperty(channel)) {\n                    var sub = this._subs[channel];\n\n                    if (sub._shouldResubscribe()) {\n                      this._subscribe(sub, wasReconnecting);\n                    }\n                  }\n                }\n\n                this.stopSubscribeBatching();\n                this.stopBatching();\n\n                this._startPing();\n\n                var ctx = {\n                  client: result.client,\n                  transport: this._transportName,\n                  latency: this._latency\n                };\n\n                if (result.data) {\n                  ctx.data = result.data;\n                }\n\n                this.emit('connect', ctx);\n\n                if (result.subs) {\n                  this._processServerSubs(result.subs);\n                }\n              }\n            }, {\n              key: \"_processServerSubs\",\n              value: function _processServerSubs(subs) {\n                for (var channel in subs) {\n                  if (subs.hasOwnProperty(channel)) {\n                    var sub = subs[channel];\n                    var isResubscribe = this._serverSubs[channel] !== undefined;\n                    var subCtx = {\n                      channel: channel,\n                      isResubscribe: isResubscribe\n                    };\n                    subCtx = this._expandSubscribeContext(subCtx, sub);\n                    this.emit('subscribe', subCtx);\n                  }\n                }\n\n                for (var _channel2 in subs) {\n                  if (subs.hasOwnProperty(_channel2)) {\n                    var _sub = subs[_channel2];\n\n                    if (_sub.recovered) {\n                      var pubs = _sub.publications;\n\n                      if (pubs && pubs.length > 0) {\n                        // handle legacy order.\n                        // TODO: remove as soon as Centrifuge v1 released.\n                        if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n                          pubs = pubs.reverse();\n                        }\n\n                        for (var i in pubs) {\n                          if (pubs.hasOwnProperty(i)) {\n                            this._handlePublication(_channel2, pubs[i]);\n                          }\n                        }\n                      }\n                    }\n\n                    this._serverSubs[_channel2] = {\n                      'seq': _sub.seq,\n                      'gen': _sub.gen,\n                      'offset': _sub.offset,\n                      'epoch': _sub.epoch,\n                      'recoverable': _sub.recoverable\n                    };\n                  }\n                }\n              }\n            }, {\n              key: \"_stopPing\",\n              value: function _stopPing() {\n                if (this._pongTimeout !== null) {\n                  clearTimeout(this._pongTimeout);\n                  this._pongTimeout = null;\n                }\n\n                if (this._pingTimeout !== null) {\n                  clearTimeout(this._pingTimeout);\n                  this._pingTimeout = null;\n                }\n              }\n            }, {\n              key: \"_startPing\",\n              value: function _startPing() {\n                var _this16 = this;\n\n                if (this._config.ping !== true || this._config.pingInterval <= 0) {\n                  return;\n                }\n\n                if (!this.isConnected()) {\n                  return;\n                }\n\n                this._pingTimeout = setTimeout(function () {\n                  if (!_this16.isConnected()) {\n                    _this16._stopPing();\n\n                    return;\n                  }\n\n                  _this16.ping();\n\n                  _this16._pongTimeout = setTimeout(function () {\n                    _this16._disconnect('no ping', true);\n                  }, _this16._config.pongWaitTimeout);\n                }, this._config.pingInterval);\n              }\n            }, {\n              key: \"_restartPing\",\n              value: function _restartPing() {\n                this._stopPing();\n\n                this._startPing();\n              }\n            }, {\n              key: \"_subscribeError\",\n              value: function _subscribeError(channel, error) {\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                if (!sub._isSubscribing()) {\n                  return;\n                }\n\n                if (error.code === 0 && error.message === _errorTimeout) {\n                  // client side timeout.\n                  this._disconnect('timeout', true);\n\n                  return;\n                }\n\n                sub._setSubscribeError(error);\n              }\n            }, {\n              key: \"_expandSubscribeContext\",\n              value: function _expandSubscribeContext(ctx, result) {\n                var recovered = false;\n\n                if ('recovered' in result) {\n                  recovered = result.recovered;\n                }\n\n                ctx.recovered = recovered;\n                var positioned = false;\n\n                if ('positioned' in result) {\n                  positioned = result.positioned;\n                }\n\n                var epoch = '';\n\n                if ('epoch' in result) {\n                  epoch = result.epoch;\n                }\n\n                var offset = 0;\n\n                if ('offset' in result) {\n                  offset = result.offset;\n                }\n\n                if (positioned) {\n                  ctx.streamPosition = {\n                    'offset': offset,\n                    'epoch': epoch\n                  };\n                }\n\n                ;\n\n                if (result.data) {\n                  ctx.data = result.data;\n                }\n\n                return ctx;\n              }\n            }, {\n              key: \"_subscribeResponse\",\n              value: function _subscribeResponse(channel, isRecover, result) {\n                var _this17 = this;\n\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  return;\n                }\n\n                if (!sub._isSubscribing()) {\n                  return;\n                }\n\n                sub._setSubscribeSuccess(result);\n\n                var pubs = result.publications;\n\n                if (pubs && pubs.length > 0) {\n                  if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n                    // handle legacy order.\n                    pubs = pubs.reverse();\n                  }\n\n                  for (var i in pubs) {\n                    if (pubs.hasOwnProperty(i)) {\n                      this._handlePublication(channel, pubs[i]);\n                    }\n                  }\n                }\n\n                if (result.recoverable && (!isRecover || !result.recovered)) {\n                  this._lastSeq[channel] = result.seq || 0;\n                  this._lastGen[channel] = result.gen || 0;\n                  this._lastOffset[channel] = result.offset || 0;\n                }\n\n                this._lastEpoch[channel] = result.epoch || '';\n\n                if (result.recoverable) {\n                  sub._recoverable = true;\n                }\n\n                if (result.expires === true) {\n                  var subRefreshTimeout = setTimeout(function () {\n                    return _this17._subRefresh(channel);\n                  }, this._getTTLMilliseconds(result.ttl));\n                  this._subRefreshTimeouts[channel] = subRefreshTimeout;\n                }\n              }\n            }, {\n              key: \"_handleReply\",\n              value: function _handleReply(reply, next) {\n                var id = reply.id;\n                var result = reply.result;\n\n                if (!(id in this._callbacks)) {\n                  next();\n                  return;\n                }\n\n                var callbacks = this._callbacks[id];\n                clearTimeout(this._callbacks[id].timeout);\n                delete this._callbacks[id];\n\n                if (!(0, _utils.errorExists)(reply)) {\n                  var callback = callbacks.callback;\n\n                  if (!callback) {\n                    return;\n                  }\n\n                  callback({\n                    result: result,\n                    next: next\n                  });\n                } else {\n                  var errback = callbacks.errback;\n\n                  if (!errback) {\n                    next();\n                    return;\n                  }\n\n                  var error = reply.error;\n                  errback({\n                    error: error,\n                    next: next\n                  });\n                }\n              }\n            }, {\n              key: \"_handleJoin\",\n              value: function _handleJoin(channel, join) {\n                var ctx = {\n                  'info': join.info\n                };\n\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  if (this._isServerSub(channel)) {\n                    ctx.channel = channel;\n                    this.emit('join', ctx);\n                  }\n\n                  return;\n                }\n\n                sub.emit('join', ctx);\n              }\n            }, {\n              key: \"_handleLeave\",\n              value: function _handleLeave(channel, leave) {\n                var ctx = {\n                  'info': leave.info\n                };\n\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  if (this._isServerSub(channel)) {\n                    ctx.channel = channel;\n                    this.emit('leave', ctx);\n                  }\n\n                  return;\n                }\n\n                sub.emit('leave', ctx);\n              }\n            }, {\n              key: \"_handleUnsub\",\n              value: function _handleUnsub(channel, unsub) {\n                var ctx = {};\n\n                var sub = this._getSub(channel);\n\n                if (!sub) {\n                  if (this._isServerSub(channel)) {\n                    delete this._serverSubs[channel];\n                    ctx.channel = channel;\n                    this.emit('unsubscribe', ctx);\n                  }\n\n                  return;\n                }\n\n                sub.unsubscribe();\n\n                if (unsub.resubscribe === true) {\n                  sub.subscribe();\n                }\n              }\n            }, {\n              key: \"_handleSub\",\n              value: function _handleSub(channel, sub) {\n                this._serverSubs[channel] = {\n                  'seq': sub.seq,\n                  'gen': sub.gen,\n                  'offset': sub.offset,\n                  'epoch': sub.epoch,\n                  'recoverable': sub.recoverable\n                };\n                var ctx = {\n                  'channel': channel,\n                  isResubscribe: false\n                };\n                ctx = this._expandSubscribeContext(ctx, sub);\n                this.emit('subscribe', ctx);\n              }\n            }, {\n              key: \"_handlePublication\",\n              value: function _handlePublication(channel, pub) {\n                var sub = this._getSub(channel);\n\n                var ctx = {\n                  'data': pub.data,\n                  'seq': pub.seq,\n                  'gen': pub.gen,\n                  'offset': pub.offset\n                };\n\n                if (pub.info) {\n                  ctx.info = pub.info;\n                }\n\n                if (!sub) {\n                  if (this._isServerSub(channel)) {\n                    if (pub.seq !== undefined) {\n                      this._serverSubs[channel].seq = pub.seq;\n                    }\n\n                    if (pub.gen !== undefined) {\n                      this._serverSubs[channel].gen = pub.gen;\n                    }\n\n                    if (pub.offset !== undefined) {\n                      this._serverSubs[channel].offset = pub.offset;\n                    }\n\n                    ctx.channel = channel;\n                    this.emit('publish', ctx);\n                  }\n\n                  return;\n                }\n\n                if (pub.seq !== undefined) {\n                  this._lastSeq[channel] = pub.seq;\n                }\n\n                if (pub.gen !== undefined) {\n                  this._lastGen[channel] = pub.gen;\n                }\n\n                if (pub.offset !== undefined) {\n                  this._lastOffset[channel] = pub.offset;\n                }\n\n                sub.emit('publish', ctx);\n              }\n            }, {\n              key: \"_handleMessage\",\n              value: function _handleMessage(message) {\n                this.emit('message', message.data);\n              }\n            }, {\n              key: \"_handlePush\",\n              value: function _handlePush(data, next) {\n                var push = this._decoder.decodePush(data);\n\n                var type = 0;\n\n                if ('type' in push) {\n                  type = push['type'];\n                }\n\n                var channel = push.channel;\n\n                if (type === this._pushType.PUBLICATION) {\n                  var pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n\n                  this._handlePublication(channel, pub);\n                } else if (type === this._pushType.MESSAGE) {\n                  var message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n\n                  this._handleMessage(message);\n                } else if (type === this._pushType.JOIN) {\n                  var join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n\n                  this._handleJoin(channel, join);\n                } else if (type === this._pushType.LEAVE) {\n                  var leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n\n                  this._handleLeave(channel, leave);\n                } else if (type === this._pushType.UNSUB) {\n                  var unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n\n                  this._handleUnsub(channel, unsub);\n                } else if (type === this._pushType.SUB) {\n                  var sub = this._decoder.decodePushData(this._pushType.SUB, push.data);\n\n                  this._handleSub(channel, sub);\n                }\n\n                next();\n              }\n            }, {\n              key: \"_flush\",\n              value: function _flush() {\n                var messages = this._messages.slice(0);\n\n                this._messages = [];\n\n                this._transportSend(messages);\n              }\n            }, {\n              key: \"_ping\",\n              value: function _ping() {\n                var _this18 = this;\n\n                var msg = {\n                  method: this._methodType.PING\n                };\n\n                this._call(msg).then(function (resolveCtx) {\n                  _this18._pingResponse(_this18._decoder.decodeCommandResult(_this18._methodType.PING, resolveCtx.result));\n\n                  if (resolveCtx.next) {\n                    resolveCtx.next();\n                  }\n                }, function (rejectCtx) {\n                  _this18._debug('ping error', rejectCtx.error);\n\n                  if (rejectCtx.next) {\n                    rejectCtx.next();\n                  }\n                });\n              }\n            }, {\n              key: \"_pingResponse\",\n              value: function _pingResponse(result) {\n                if (!this.isConnected()) {\n                  return;\n                }\n\n                this._stopPing();\n\n                this._startPing();\n              }\n            }, {\n              key: \"_getLastSeq\",\n              value: function _getLastSeq(channel) {\n                var lastSeq = this._lastSeq[channel];\n\n                if (lastSeq) {\n                  return lastSeq;\n                }\n\n                return 0;\n              }\n            }, {\n              key: \"_getLastOffset\",\n              value: function _getLastOffset(channel) {\n                var lastOffset = this._lastOffset[channel];\n\n                if (lastOffset) {\n                  return lastOffset;\n                }\n\n                return 0;\n              }\n            }, {\n              key: \"_getLastGen\",\n              value: function _getLastGen(channel) {\n                var lastGen = this._lastGen[channel];\n\n                if (lastGen) {\n                  return lastGen;\n                }\n\n                return 0;\n              }\n            }, {\n              key: \"_getLastEpoch\",\n              value: function _getLastEpoch(channel) {\n                var lastEpoch = this._lastEpoch[channel];\n\n                if (lastEpoch) {\n                  return lastEpoch;\n                }\n\n                return '';\n              }\n            }, {\n              key: \"_createErrorObject\",\n              value: function _createErrorObject(message, code) {\n                var errObject = {\n                  message: message,\n                  code: code || 0\n                };\n                return errObject;\n              }\n            }, {\n              key: \"_registerCall\",\n              value: function _registerCall(id, callback, errback) {\n                var _this19 = this;\n\n                this._callbacks[id] = {\n                  callback: callback,\n                  errback: errback,\n                  timeout: null\n                };\n                this._callbacks[id].timeout = setTimeout(function () {\n                  delete _this19._callbacks[id];\n\n                  if ((0, _utils.isFunction)(errback)) {\n                    errback({\n                      error: _this19._createErrorObject(_errorTimeout)\n                    });\n                  }\n                }, this._config.timeout);\n              }\n            }, {\n              key: \"_addMessage\",\n              value: function _addMessage(message) {\n                var id = this._nextMessageId();\n\n                message.id = id;\n\n                if (this._isBatching === true) {\n                  this._messages.push(message);\n                } else {\n                  this._transportSend([message]);\n                }\n\n                return id;\n              }\n            }, {\n              key: \"isConnected\",\n              value: function isConnected() {\n                return this._isConnected();\n              }\n            }, {\n              key: \"connect\",\n              value: function connect() {\n                this._connect();\n              }\n            }, {\n              key: \"disconnect\",\n              value: function disconnect() {\n                this._disconnect('client', false);\n              }\n            }, {\n              key: \"ping\",\n              value: function ping() {\n                return this._ping();\n              }\n            }, {\n              key: \"startBatching\",\n              value: function startBatching() {\n                // start collecting messages without sending them to Centrifuge until flush\n                // method called\n                this._isBatching = true;\n              }\n            }, {\n              key: \"stopBatching\",\n              value: function stopBatching() {\n                this._isBatching = false;\n\n                this._flush();\n              }\n            }, {\n              key: \"startSubscribeBatching\",\n              value: function startSubscribeBatching() {\n                // start collecting private channels to create bulk authentication\n                // request to subscribeEndpoint when stopSubscribeBatching will be called\n                this._isSubscribeBatching = true;\n              }\n            }, {\n              key: \"stopSubscribeBatching\",\n              value: function stopSubscribeBatching() {\n                var _this20 = this; // create request to subscribeEndpoint with collected private channels\n                // to ask if this client can subscribe on each channel\n\n\n                this._isSubscribeBatching = false;\n                var authChannels = this._privateChannels;\n                this._privateChannels = {};\n                var channels = [];\n\n                for (var channel in authChannels) {\n                  if (authChannels.hasOwnProperty(channel)) {\n                    var sub = this._getSub(channel);\n\n                    if (!sub) {\n                      continue;\n                    }\n\n                    channels.push(channel);\n                  }\n                }\n\n                if (channels.length === 0) {\n                  this._debug('no private channels found, no need to make request');\n\n                  return;\n                }\n\n                var data = {\n                  client: this._clientID,\n                  channels: channels\n                };\n                var clientID = this._clientID;\n\n                var xhrID = this._newXHRID();\n\n                var cb = function cb(resp) {\n                  if (xhrID in _this20._xhrs) {\n                    delete _this20._xhrs[xhrID];\n                  }\n\n                  if (_this20._clientID !== clientID) {\n                    return;\n                  }\n\n                  if (resp.error || resp.status !== 200) {\n                    _this20._debug('authorization request failed');\n\n                    for (var i in channels) {\n                      if (channels.hasOwnProperty(i)) {\n                        var _channel3 = channels[i];\n\n                        _this20._subscribeError(_channel3, _this20._createErrorObject('authorization request failed'));\n                      }\n                    }\n\n                    return;\n                  }\n\n                  var channelsData = {};\n\n                  if (resp.data.channels) {\n                    for (var _i in resp.data.channels) {\n                      var channelData = resp.data.channels[_i];\n\n                      if (!channelData.channel) {\n                        continue;\n                      }\n\n                      channelsData[channelData.channel] = channelData.token;\n                    }\n                  } // try to send all subscriptions in one request.\n\n\n                  var batch = false;\n\n                  if (!_this20._isBatching) {\n                    _this20.startBatching();\n\n                    batch = true;\n                  }\n\n                  for (var _i2 in channels) {\n                    if (channels.hasOwnProperty(_i2)) {\n                      var _ret = function () {\n                        var channel = channels[_i2];\n                        var token = channelsData[channel];\n\n                        if (!token) {\n                          // subscription:error\n                          _this20._subscribeError(channel, _this20._createErrorObject('permission denied', 103));\n\n                          return \"continue\";\n                        } else {\n                          var msg = {\n                            method: _this20._methodType.SUBSCRIBE,\n                            params: {\n                              channel: channel,\n                              token: token\n                            }\n                          };\n\n                          var _sub2 = _this20._getSub(channel);\n\n                          if (_sub2 === null) {\n                            return \"continue\";\n                          }\n\n                          var recover = _sub2._needRecover();\n\n                          if (recover === true) {\n                            msg.params.recover = true;\n\n                            var seq = _this20._getLastSeq(channel);\n\n                            var gen = _this20._getLastGen(channel);\n\n                            if (seq || gen) {\n                              if (seq) {\n                                msg.params.seq = seq;\n                              }\n\n                              if (gen) {\n                                msg.params.gen = gen;\n                              }\n                            } else {\n                              var offset = _this20._getLastOffset(channel);\n\n                              if (offset) {\n                                msg.params.offset = offset;\n                              }\n                            }\n\n                            var epoch = _this20._getLastEpoch(channel);\n\n                            if (epoch) {\n                              msg.params.epoch = epoch;\n                            }\n                          }\n\n                          _this20._call(msg).then(function (resolveCtx) {\n                            _this20._subscribeResponse(channel, recover, _this20._decoder.decodeCommandResult(_this20._methodType.SUBSCRIBE, resolveCtx.result));\n\n                            if (resolveCtx.next) {\n                              resolveCtx.next();\n                            }\n                          }, function (rejectCtx) {\n                            _this20._subscribeError(channel, rejectCtx.error);\n\n                            if (rejectCtx.next) {\n                              rejectCtx.next();\n                            }\n                          });\n                        }\n                      }();\n\n                      if (_ret === \"continue\") continue;\n                    }\n                  }\n\n                  if (batch) {\n                    _this20.stopBatching();\n                  }\n                };\n\n                if (this._config.onPrivateSubscribe !== null) {\n                  this._config.onPrivateSubscribe({\n                    data: data\n                  }, cb);\n                } else {\n                  var xhr = this._ajax(this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n\n                  this._xhrs[xhrID] = xhr;\n                }\n              }\n            }, {\n              key: \"subscribe\",\n              value: function subscribe(channel, events) {\n                var currentSub = this._getSub(channel);\n\n                if (currentSub !== null) {\n                  currentSub._setEvents(events);\n\n                  if (currentSub._isUnsubscribed()) {\n                    currentSub.subscribe();\n                  }\n\n                  return currentSub;\n                }\n\n                var sub = new _subscription[\"default\"](this, channel, events);\n                this._subs[channel] = sub;\n                sub.subscribe();\n                return sub;\n              }\n            }]);\n\n            return Centrifuge;\n          }(_events[\"default\"]);\n\n          exports.Centrifuge = Centrifuge;\n          /***/\n        },\n\n        /***/\n        579:\n        /***/\n        function _(module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.default = void 0;\n\n          var _centrifuge = __webpack_require__(382);\n\n          var _default = _centrifuge.Centrifuge;\n          exports.default = _default;\n          module.exports = exports[\"default\"];\n          /***/\n        },\n\n        /***/\n        147:\n        /***/\n        function _(__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.JsonDecoder = exports.JsonEncoder = exports.JsonPushType = exports.JsonMethodType = void 0;\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n\n          var JsonMethodType = {\n            CONNECT: 0,\n            SUBSCRIBE: 1,\n            UNSUBSCRIBE: 2,\n            PUBLISH: 3,\n            PRESENCE: 4,\n            PRESENCE_STATS: 5,\n            HISTORY: 6,\n            PING: 7,\n            SEND: 8,\n            RPC: 9,\n            REFRESH: 10,\n            SUB_REFRESH: 11\n          };\n          exports.JsonMethodType = JsonMethodType;\n          var JsonPushType = {\n            PUBLICATION: 0,\n            JOIN: 1,\n            LEAVE: 2,\n            UNSUB: 3,\n            MESSAGE: 4,\n            SUB: 5\n          };\n          exports.JsonPushType = JsonPushType;\n\n          var JsonEncoder = /*#__PURE__*/function () {\n            function JsonEncoder() {\n              _classCallCheck(this, JsonEncoder);\n            }\n\n            _createClass(JsonEncoder, [{\n              key: \"encodeCommands\",\n              value: function encodeCommands(commands) {\n                return commands.map(function (c) {\n                  return JSON.stringify(c);\n                }).join('\\n');\n              }\n            }]);\n\n            return JsonEncoder;\n          }();\n\n          exports.JsonEncoder = JsonEncoder;\n\n          var JsonDecoder = /*#__PURE__*/function () {\n            function JsonDecoder() {\n              _classCallCheck(this, JsonDecoder);\n            }\n\n            _createClass(JsonDecoder, [{\n              key: \"decodeReplies\",\n              value: function decodeReplies(data) {\n                return data.split('\\n').filter(function (r) {\n                  return r !== '';\n                }).map(function (r) {\n                  return JSON.parse(r);\n                });\n              }\n            }, {\n              key: \"decodeCommandResult\",\n              value: function decodeCommandResult(methodType, data) {\n                return data;\n              }\n            }, {\n              key: \"decodePush\",\n              value: function decodePush(data) {\n                return data;\n              }\n            }, {\n              key: \"decodePushData\",\n              value: function decodePushData(pushType, data) {\n                return data;\n              }\n            }]);\n\n            return JsonDecoder;\n          }();\n\n          exports.JsonDecoder = JsonDecoder;\n          /***/\n        },\n\n        /***/\n        471:\n        /***/\n        function _(module, exports, __webpack_require__) {\n          function _typeof(obj) {\n            \"@babel/helpers - typeof\";\n\n            if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n              _typeof = function _typeof(obj) {\n                return typeof obj;\n              };\n            } else {\n              _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n              };\n            }\n\n            return _typeof(obj);\n          }\n\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.default = void 0;\n\n          var _events = _interopRequireDefault(__webpack_require__(187));\n\n          var _utils = __webpack_require__(853);\n\n          function _interopRequireDefault(obj) {\n            return obj && obj.__esModule ? obj : {\n              \"default\": obj\n            };\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n\n          function _inherits(subClass, superClass) {\n            if (typeof superClass !== \"function\" && superClass !== null) {\n              throw new TypeError(\"Super expression must either be null or a function\");\n            }\n\n            subClass.prototype = Object.create(superClass && superClass.prototype, {\n              constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true\n              }\n            });\n            if (superClass) _setPrototypeOf(subClass, superClass);\n          }\n\n          function _setPrototypeOf(o, p) {\n            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n              o.__proto__ = p;\n              return o;\n            };\n\n            return _setPrototypeOf(o, p);\n          }\n\n          function _createSuper(Derived) {\n            var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n            return function _createSuperInternal() {\n              var Super = _getPrototypeOf(Derived),\n                  result;\n\n              if (hasNativeReflectConstruct) {\n                var NewTarget = _getPrototypeOf(this).constructor;\n\n                result = Reflect.construct(Super, arguments, NewTarget);\n              } else {\n                result = Super.apply(this, arguments);\n              }\n\n              return _possibleConstructorReturn(this, result);\n            };\n          }\n\n          function _possibleConstructorReturn(self, call) {\n            if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n              return call;\n            }\n\n            return _assertThisInitialized(self);\n          }\n\n          function _assertThisInitialized(self) {\n            if (self === void 0) {\n              throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n            }\n\n            return self;\n          }\n\n          function _isNativeReflectConstruct() {\n            if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n            if (Reflect.construct.sham) return false;\n            if (typeof Proxy === \"function\") return true;\n\n            try {\n              Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n              return true;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          function _getPrototypeOf(o) {\n            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n              return o.__proto__ || Object.getPrototypeOf(o);\n            };\n            return _getPrototypeOf(o);\n          }\n\n          var _STATE_NEW = 0;\n          var _STATE_SUBSCRIBING = 1;\n          var _STATE_SUCCESS = 2;\n          var _STATE_ERROR = 3;\n          var _STATE_UNSUBSCRIBED = 4;\n\n          var Subscription = /*#__PURE__*/function (_EventEmitter) {\n            _inherits(Subscription, _EventEmitter);\n\n            var _super = _createSuper(Subscription);\n\n            function Subscription(centrifuge, channel, events) {\n              var _this;\n\n              _classCallCheck(this, Subscription);\n\n              _this = _super.call(this);\n              _this.channel = channel;\n              _this._centrifuge = centrifuge;\n              _this._status = _STATE_NEW;\n              _this._error = null;\n              _this._isResubscribe = false;\n              _this._ready = false;\n              _this._subscriptionPromise = null;\n              _this._noResubscribe = false;\n              _this._recoverable = false;\n              _this._recover = false;\n\n              _this._setEvents(events);\n\n              _this._initializePromise();\n\n              _this._promises = {};\n              _this._promiseId = 0;\n\n              _this.on('error', function (errContext) {\n                this._centrifuge._debug('subscription error', errContext);\n              });\n\n              return _this;\n            }\n\n            _createClass(Subscription, [{\n              key: \"_nextPromiseId\",\n              value: function _nextPromiseId() {\n                return ++this._promiseId;\n              }\n            }, {\n              key: \"_initializePromise\",\n              value: function _initializePromise() {\n                var _this2 = this; // this helps us to wait until subscription will successfully\n                // subscribe and call actions such as presence, history etc in\n                // synchronous way.\n\n\n                this._ready = false;\n                this._subscriptionPromise = new Promise(function (resolve, reject) {\n                  _this2._resolve = function (value) {\n                    _this2._ready = true;\n                    resolve(value);\n                  };\n\n                  _this2._reject = function (err) {\n                    _this2._ready = true;\n                    reject(err);\n                  };\n                }).then(function () {}, function () {});\n              }\n            }, {\n              key: \"_needRecover\",\n              value: function _needRecover() {\n                return this._recoverable === true && this._recover === true;\n              }\n            }, {\n              key: \"_setEvents\",\n              value: function _setEvents(events) {\n                if (!events) {\n                  return;\n                }\n\n                if ((0, _utils.isFunction)(events)) {\n                  // events is just a function to handle publication received from channel.\n                  this.on('publish', events);\n                } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n                  var knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n\n                  for (var i = 0, l = knownEvents.length; i < l; i++) {\n                    var ev = knownEvents[i];\n\n                    if (ev in events) {\n                      this.on(ev, events[ev]);\n                    }\n                  }\n                }\n              }\n            }, {\n              key: \"_isNew\",\n              value: function _isNew() {\n                return this._status === _STATE_NEW;\n              }\n            }, {\n              key: \"_isUnsubscribed\",\n              value: function _isUnsubscribed() {\n                return this._status === _STATE_UNSUBSCRIBED;\n              }\n            }, {\n              key: \"_isSubscribing\",\n              value: function _isSubscribing() {\n                return this._status === _STATE_SUBSCRIBING;\n              }\n            }, {\n              key: \"_isReady\",\n              value: function _isReady() {\n                return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n              }\n            }, {\n              key: \"_isSuccess\",\n              value: function _isSuccess() {\n                return this._status === _STATE_SUCCESS;\n              }\n            }, {\n              key: \"_isError\",\n              value: function _isError() {\n                return this._status === _STATE_ERROR;\n              }\n            }, {\n              key: \"_setNew\",\n              value: function _setNew() {\n                this._status = _STATE_NEW;\n              }\n            }, {\n              key: \"_setSubscribing\",\n              value: function _setSubscribing(isResubscribe) {\n                this._isResubscribe = isResubscribe || false;\n\n                if (this._ready === true) {\n                  // new promise for this subscription\n                  this._initializePromise();\n                }\n\n                this._status = _STATE_SUBSCRIBING;\n              }\n            }, {\n              key: \"_setSubscribeSuccess\",\n              value: function _setSubscribeSuccess(subscribeResult) {\n                if (this._status === _STATE_SUCCESS) {\n                  return;\n                }\n\n                this._status = _STATE_SUCCESS;\n\n                var successContext = this._getSubscribeSuccessContext(subscribeResult);\n\n                this._recover = false;\n                this.emit('subscribe', successContext);\n\n                this._resolve(successContext);\n\n                for (var id in this._promises) {\n                  clearTimeout(this._promises[id].timeout);\n\n                  this._promises[id].resolve();\n\n                  delete this._promises[id];\n                }\n              }\n            }, {\n              key: \"_setSubscribeError\",\n              value: function _setSubscribeError(err) {\n                if (this._status === _STATE_ERROR) {\n                  return;\n                }\n\n                this._status = _STATE_ERROR;\n                this._error = err;\n\n                var errContext = this._getSubscribeErrorContext();\n\n                this.emit('error', errContext);\n\n                this._reject(errContext);\n\n                for (var id in this._promises) {\n                  clearTimeout(this._promises[id].timeout);\n\n                  this._promises[id].reject(err);\n\n                  delete this._promises[id];\n                }\n              }\n            }, {\n              key: \"_triggerUnsubscribe\",\n              value: function _triggerUnsubscribe() {\n                this.emit('unsubscribe', {\n                  channel: this.channel\n                });\n              }\n            }, {\n              key: \"_setUnsubscribed\",\n              value: function _setUnsubscribed(noResubscribe) {\n                this._centrifuge._clearSubRefreshTimeout(this.channel);\n\n                if (this._status === _STATE_UNSUBSCRIBED) {\n                  return;\n                }\n\n                var needTrigger = this._status === _STATE_SUCCESS;\n                this._status = _STATE_UNSUBSCRIBED;\n\n                if (noResubscribe === true) {\n                  this._recover = false;\n                  this._noResubscribe = true;\n                  delete this._centrifuge._lastSeq[this.channel];\n                  delete this._centrifuge._lastGen[this.channel];\n                  delete this._centrifuge._lastEpoch[this.channel];\n                }\n\n                if (needTrigger) {\n                  this._triggerUnsubscribe();\n                }\n              }\n            }, {\n              key: \"_shouldResubscribe\",\n              value: function _shouldResubscribe() {\n                return !this._noResubscribe;\n              }\n            }, {\n              key: \"_getSubscribeSuccessContext\",\n              value: function _getSubscribeSuccessContext(subscribeResult) {\n                var ctx = {\n                  channel: this.channel,\n                  isResubscribe: this._isResubscribe\n                };\n\n                if (subscribeResult) {\n                  // subscribeResult not available when called from Subscription.ready method at the moment.\n                  ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n                }\n\n                return ctx;\n              }\n            }, {\n              key: \"_getSubscribeErrorContext\",\n              value: function _getSubscribeErrorContext() {\n                var subscribeErrorContext = this._error;\n                subscribeErrorContext.channel = this.channel;\n                subscribeErrorContext.isResubscribe = this._isResubscribe;\n                return subscribeErrorContext;\n              }\n            }, {\n              key: \"ready\",\n              value: function ready(callback, errback) {\n                if (this._ready) {\n                  if (this._isSuccess()) {\n                    callback(this._getSubscribeSuccessContext());\n                  } else {\n                    errback(this._getSubscribeErrorContext());\n                  }\n                }\n              }\n            }, {\n              key: \"subscribe\",\n              value: function subscribe() {\n                if (this._status === _STATE_SUCCESS) {\n                  return;\n                }\n\n                this._noResubscribe = false;\n\n                this._centrifuge._subscribe(this);\n              }\n            }, {\n              key: \"unsubscribe\",\n              value: function unsubscribe() {\n                this._setUnsubscribed(true);\n\n                this._centrifuge._unsubscribe(this);\n              }\n            }, {\n              key: \"_methodCall\",\n              value: function _methodCall() {\n                var _this3 = this;\n\n                if (this._isSuccess()) {\n                  return Promise.resolve();\n                } else if (this._isError()) {\n                  return Promise.reject(this._error);\n                }\n\n                var subPromise = new Promise(function (res, rej) {\n                  var timeout = setTimeout(function () {\n                    rej({\n                      'code': 0,\n                      'message': 'timeout'\n                    });\n                  }, _this3._centrifuge._config.timeout);\n                  _this3._promises[_this3._nextPromiseId()] = {\n                    timeout: timeout,\n                    resolve: res,\n                    reject: rej\n                  };\n                });\n                return subPromise;\n              }\n            }, {\n              key: \"publish\",\n              value: function publish(data) {\n                var self = this;\n                return this._methodCall().then(function () {\n                  return self._centrifuge.publish(self.channel, data);\n                });\n              }\n            }, {\n              key: \"presence\",\n              value: function presence() {\n                var self = this;\n                return this._methodCall().then(function () {\n                  return self._centrifuge.presence(self.channel);\n                });\n              }\n            }, {\n              key: \"presenceStats\",\n              value: function presenceStats() {\n                var self = this;\n                return this._methodCall().then(function () {\n                  return self._centrifuge.presenceStats(self.channel);\n                });\n              }\n            }, {\n              key: \"history\",\n              value: function history(options) {\n                var self = this;\n                return this._methodCall().then(function () {\n                  return self._centrifuge.history(self.channel, options);\n                });\n              }\n            }]);\n\n            return Subscription;\n          }(_events[\"default\"]);\n\n          exports.default = Subscription;\n          module.exports = exports[\"default\"];\n          /***/\n        },\n\n        /***/\n        853:\n        /***/\n        function _(__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.startsWith = startsWith;\n          exports.isFunction = isFunction;\n          exports.log = log;\n          exports.backoff = backoff;\n          exports.errorExists = errorExists;\n          exports.extend = extend;\n\n          function startsWith(value, prefix) {\n            return value.lastIndexOf(prefix, 0) === 0;\n          }\n\n          ;\n\n          function isFunction(value) {\n            if (value === undefined || value === null) {\n              return false;\n            }\n\n            return typeof value === 'function';\n          }\n\n          ;\n\n          function log(level, args) {\n            if (__webpack_require__.g.console) {\n              var logger = __webpack_require__.g.console[level];\n\n              if (isFunction(logger)) {\n                logger.apply(__webpack_require__.g.console, args);\n              }\n            }\n          }\n\n          ;\n\n          function backoff(step, min, max) {\n            var jitter = 0.5 * Math.random();\n            var interval = Math.min(max, min * Math.pow(2, step + 1));\n            return Math.floor((1 - jitter) * interval);\n          }\n\n          ;\n\n          function errorExists(data) {\n            return 'error' in data && data.error !== null;\n          }\n\n          ;\n\n          function extend(a, b) {\n            for (var key in b) {\n              if (b.hasOwnProperty(key)) {\n                a[key] = b[key];\n              }\n            }\n\n            return a;\n          }\n\n          ;\n          /***/\n        },\n\n        /***/\n        187:\n        /***/\n        function _(module) {\n          // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          var R = typeof Reflect === 'object' ? Reflect : null;\n          var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n            return Function.prototype.apply.call(target, receiver, args);\n          };\n          var ReflectOwnKeys;\n\n          if (R && typeof R.ownKeys === 'function') {\n            ReflectOwnKeys = R.ownKeys;\n          } else if (Object.getOwnPropertySymbols) {\n            ReflectOwnKeys = function ReflectOwnKeys(target) {\n              return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n            };\n          } else {\n            ReflectOwnKeys = function ReflectOwnKeys(target) {\n              return Object.getOwnPropertyNames(target);\n            };\n          }\n\n          function ProcessEmitWarning(warning) {\n            if (console && console.warn) console.warn(warning);\n          }\n\n          var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n            return value !== value;\n          };\n\n          function EventEmitter() {\n            EventEmitter.init.call(this);\n          }\n\n          module.exports = EventEmitter;\n          module.exports.once = once; // Backwards-compat with node 0.10.x\n\n          EventEmitter.EventEmitter = EventEmitter;\n          EventEmitter.prototype._events = undefined;\n          EventEmitter.prototype._eventsCount = 0;\n          EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n          // added to it. This is a useful default which helps finding memory leaks.\n\n          var defaultMaxListeners = 10;\n\n          function checkListener(listener) {\n            if (typeof listener !== 'function') {\n              throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n            }\n          }\n\n          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n            enumerable: true,\n            get: function get() {\n              return defaultMaxListeners;\n            },\n            set: function set(arg) {\n              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n                throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n              }\n\n              defaultMaxListeners = arg;\n            }\n          });\n\n          EventEmitter.init = function () {\n            if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n              this._events = Object.create(null);\n              this._eventsCount = 0;\n            }\n\n            this._maxListeners = this._maxListeners || undefined;\n          }; // Obviously not all Emitters should be limited to 10. This function allows\n          // that to be increased. Set to zero for unlimited.\n\n\n          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n              throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n            }\n\n            this._maxListeners = n;\n            return this;\n          };\n\n          function _getMaxListeners(that) {\n            if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n            return that._maxListeners;\n          }\n\n          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n            return _getMaxListeners(this);\n          };\n\n          EventEmitter.prototype.emit = function emit(type) {\n            var args = [];\n\n            for (var i = 1; i < arguments.length; i++) {\n              args.push(arguments[i]);\n            }\n\n            var doError = type === 'error';\n            var events = this._events;\n            if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n            if (doError) {\n              var er;\n              if (args.length > 0) er = args[0];\n\n              if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n              } // At least give some kind of context to the user\n\n\n              var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n              err.context = er;\n              throw err; // Unhandled 'error' event\n            }\n\n            var handler = events[type];\n            if (handler === undefined) return false;\n\n            if (typeof handler === 'function') {\n              ReflectApply(handler, this, args);\n            } else {\n              var len = handler.length;\n              var listeners = arrayClone(handler, len);\n\n              for (var i = 0; i < len; ++i) {\n                ReflectApply(listeners[i], this, args);\n              }\n            }\n\n            return true;\n          };\n\n          function _addListener(target, type, listener, prepend) {\n            var m;\n            var events;\n            var existing;\n            checkListener(listener);\n            events = target._events;\n\n            if (events === undefined) {\n              events = target._events = Object.create(null);\n              target._eventsCount = 0;\n            } else {\n              // To avoid recursion in the case that type === \"newListener\"! Before\n              // adding it to the listeners, first emit \"newListener\".\n              if (events.newListener !== undefined) {\n                target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n                // this._events to be assigned to a new object\n\n                events = target._events;\n              }\n\n              existing = events[type];\n            }\n\n            if (existing === undefined) {\n              // Optimize the case of one listener. Don't need the extra array object.\n              existing = events[type] = listener;\n              ++target._eventsCount;\n            } else {\n              if (typeof existing === 'function') {\n                // Adding the second element, need to change to array.\n                existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n              } else if (prepend) {\n                existing.unshift(listener);\n              } else {\n                existing.push(listener);\n              } // Check for listener leak\n\n\n              m = _getMaxListeners(target);\n\n              if (m > 0 && existing.length > m && !existing.warned) {\n                existing.warned = true; // No error code for this since it is a Warning\n                // eslint-disable-next-line no-restricted-syntax\n\n                var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n                w.name = 'MaxListenersExceededWarning';\n                w.emitter = target;\n                w.type = type;\n                w.count = existing.length;\n                ProcessEmitWarning(w);\n              }\n            }\n\n            return target;\n          }\n\n          EventEmitter.prototype.addListener = function addListener(type, listener) {\n            return _addListener(this, type, listener, false);\n          };\n\n          EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n          EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n            return _addListener(this, type, listener, true);\n          };\n\n          function onceWrapper() {\n            if (!this.fired) {\n              this.target.removeListener(this.type, this.wrapFn);\n              this.fired = true;\n              if (arguments.length === 0) return this.listener.call(this.target);\n              return this.listener.apply(this.target, arguments);\n            }\n          }\n\n          function _onceWrap(target, type, listener) {\n            var state = {\n              fired: false,\n              wrapFn: undefined,\n              target: target,\n              type: type,\n              listener: listener\n            };\n            var wrapped = onceWrapper.bind(state);\n            wrapped.listener = listener;\n            state.wrapFn = wrapped;\n            return wrapped;\n          }\n\n          EventEmitter.prototype.once = function once(type, listener) {\n            checkListener(listener);\n            this.on(type, _onceWrap(this, type, listener));\n            return this;\n          };\n\n          EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n            checkListener(listener);\n            this.prependListener(type, _onceWrap(this, type, listener));\n            return this;\n          }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n          EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n            var list, events, position, i, originalListener;\n            checkListener(listener);\n            events = this._events;\n            if (events === undefined) return this;\n            list = events[type];\n            if (list === undefined) return this;\n\n            if (list === listener || list.listener === listener) {\n              if (--this._eventsCount === 0) this._events = Object.create(null);else {\n                delete events[type];\n                if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n              }\n            } else if (typeof list !== 'function') {\n              position = -1;\n\n              for (i = list.length - 1; i >= 0; i--) {\n                if (list[i] === listener || list[i].listener === listener) {\n                  originalListener = list[i].listener;\n                  position = i;\n                  break;\n                }\n              }\n\n              if (position < 0) return this;\n              if (position === 0) list.shift();else {\n                spliceOne(list, position);\n              }\n              if (list.length === 1) events[type] = list[0];\n              if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n            }\n\n            return this;\n          };\n\n          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n          EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n            var listeners, events, i;\n            events = this._events;\n            if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n            if (events.removeListener === undefined) {\n              if (arguments.length === 0) {\n                this._events = Object.create(null);\n                this._eventsCount = 0;\n              } else if (events[type] !== undefined) {\n                if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n              }\n\n              return this;\n            } // emit removeListener for all listeners on all events\n\n\n            if (arguments.length === 0) {\n              var keys = Object.keys(events);\n              var key;\n\n              for (i = 0; i < keys.length; ++i) {\n                key = keys[i];\n                if (key === 'removeListener') continue;\n                this.removeAllListeners(key);\n              }\n\n              this.removeAllListeners('removeListener');\n              this._events = Object.create(null);\n              this._eventsCount = 0;\n              return this;\n            }\n\n            listeners = events[type];\n\n            if (typeof listeners === 'function') {\n              this.removeListener(type, listeners);\n            } else if (listeners !== undefined) {\n              // LIFO order\n              for (i = listeners.length - 1; i >= 0; i--) {\n                this.removeListener(type, listeners[i]);\n              }\n            }\n\n            return this;\n          };\n\n          function _listeners(target, type, unwrap) {\n            var events = target._events;\n            if (events === undefined) return [];\n            var evlistener = events[type];\n            if (evlistener === undefined) return [];\n            if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n          }\n\n          EventEmitter.prototype.listeners = function listeners(type) {\n            return _listeners(this, type, true);\n          };\n\n          EventEmitter.prototype.rawListeners = function rawListeners(type) {\n            return _listeners(this, type, false);\n          };\n\n          EventEmitter.listenerCount = function (emitter, type) {\n            if (typeof emitter.listenerCount === 'function') {\n              return emitter.listenerCount(type);\n            } else {\n              return listenerCount.call(emitter, type);\n            }\n          };\n\n          EventEmitter.prototype.listenerCount = listenerCount;\n\n          function listenerCount(type) {\n            var events = this._events;\n\n            if (events !== undefined) {\n              var evlistener = events[type];\n\n              if (typeof evlistener === 'function') {\n                return 1;\n              } else if (evlistener !== undefined) {\n                return evlistener.length;\n              }\n            }\n\n            return 0;\n          }\n\n          EventEmitter.prototype.eventNames = function eventNames() {\n            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n          };\n\n          function arrayClone(arr, n) {\n            var copy = new Array(n);\n\n            for (var i = 0; i < n; ++i) {\n              copy[i] = arr[i];\n            }\n\n            return copy;\n          }\n\n          function spliceOne(list, index) {\n            for (; index + 1 < list.length; index++) {\n              list[index] = list[index + 1];\n            }\n\n            list.pop();\n          }\n\n          function unwrapListeners(arr) {\n            var ret = new Array(arr.length);\n\n            for (var i = 0; i < ret.length; ++i) {\n              ret[i] = arr[i].listener || arr[i];\n            }\n\n            return ret;\n          }\n\n          function once(emitter, name) {\n            return new Promise(function (resolve, reject) {\n              function eventListener() {\n                if (errorListener !== undefined) {\n                  emitter.removeListener('error', errorListener);\n                }\n\n                resolve([].slice.call(arguments));\n              }\n\n              ;\n              var errorListener; // Adding an error listener is not optional because\n              // if an error is thrown on an event emitter we cannot\n              // guarantee that the actual event we are waiting will\n              // be fired. The result could be a silent way to create\n              // memory or file descriptor leaks, which is something\n              // we should avoid.\n\n              if (name !== 'error') {\n                errorListener = function errorListener(err) {\n                  emitter.removeListener(name, eventListener);\n                  reject(err);\n                };\n\n                emitter.once('error', errorListener);\n              }\n\n              emitter.once(name, eventListener);\n            });\n          }\n          /***/\n\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __webpack_require__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          // no module.id needed\n\n          /******/\n          // no module.loaded needed\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/global */\n\n      /******/\n\n\n      !function () {\n        /******/\n        __webpack_require__.g = function () {\n          /******/\n          if (typeof globalThis === 'object') return globalThis;\n          /******/\n\n          try {\n            /******/\n            return this || new Function('return this')();\n            /******/\n          } catch (e) {\n            /******/\n            if (typeof window === 'object') return window;\n            /******/\n          }\n          /******/\n\n        }();\n        /******/\n\n      }();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n      return __webpack_require__(579);\n      /******/\n    }()\n  );\n});","map":{"version":3,"sources":["webpack://Centrifuge/webpack/universalModuleDefinition","webpack://Centrifuge/src/centrifuge.js","webpack://Centrifuge/src/index.js","webpack://Centrifuge/src/json.js","webpack://Centrifuge/src/subscription.js","webpack://Centrifuge/src/utils.js","webpack://Centrifuge/node_modules/events/events.js","webpack://Centrifuge/webpack/bootstrap","webpack://Centrifuge/webpack/runtime/global","webpack://Centrifuge/webpack/startup"],"names":["_errorTimeout","_errorConnectionClosed","Centrifuge","EventEmitter","Promise","debug","name","version","websocket","sockjs","xmlhttprequest","minRetry","maxRetry","timeout","ping","pingInterval","pongWaitTimeout","privateChannelPrefix","onTransportClose","sockjsServer","sockjsTransports","refreshEndpoint","refreshHeaders","refreshParams","refreshData","refreshAttempts","refreshInterval","onRefreshFailed","onRefresh","subscribeEndpoint","subscribeHeaders","subscribeParams","subRefreshInterval","onPrivateSubscribe","token","data","headers","params","url","callback","query","JSON","xhr","global","encodeURIComponent","parsed","error","status","setTimeout","format","JsonMethodType","JsonPushType","JsonEncoder","JsonDecoder","configuration","newStatus","interval","reconnect","callbacks","clearTimeout","errback","sub","commands","id","command","sockjsOptions","transports","msg","subs","hasSubs","resolveCtx","err","rejectCtx","reason","needReconnect","closeEvent","advice","event","method","sent","channel","options","resultCB","resolve","reject","result","presence","num_clients","replies","finishDispatch","p","i","reply","next","shouldReconnect","clientID","xhrID","cb","resp","jitter","Math","_token","context","channelsData","channelData","client","channels","subRefreshTimeout","isResubscribe","recover","seq","gen","offset","epoch","ttl","isRecover","wasReconnecting","ctx","transport","latency","_latency","subCtx","pubs","recoverable","recovered","positioned","join","info","leave","unsub","pub","message","push","type","messages","PING","lastSeq","lastOffset","lastGen","lastEpoch","code","errObject","authChannels","batch","events","currentSub","Subscription","CONNECT","SUBSCRIBE","UNSUBSCRIBE","PUBLISH","PRESENCE","PRESENCE_STATS","HISTORY","SEND","RPC","REFRESH","SUB_REFRESH","PUBLICATION","JOIN","LEAVE","UNSUB","MESSAGE","SUB","r","methodType","pushType","_STATE_NEW","_STATE_SUBSCRIBING","_STATE_SUCCESS","_STATE_ERROR","_STATE_UNSUBSCRIBED","Object","knownEvents","l","ev","subscribeResult","successContext","errContext","noResubscribe","needTrigger","_isResubscribe","subscribeErrorContext","subPromise","rej","self","value","logger","isFunction","min","step","b","a"],"mappings":"AAAA,CAAA,SAAA,gCAAA,CAAA,IAAA,EAAA,OAAA,EAAA;AACA,MAAA,OAAA,OAAA,KAAA,QAAA,IAAA,OAAA,MAAA,KAAA,QAAA,EACA,MAAA,CAAA,OAAA,GAAA,OAAA,EAAA,CADA,KAEA,IAAA,OAAA,MAAA,KAAA,UAAA,IAAA,MAAA,CAAA,GAAA,EACA,MAAA,CAAA,YAAA,EAAA,EAAA,EAAA,OAAA,CAAA,CADA,KAEA,IAAA,OAAA,OAAA,KAAA,QAAA,EACA,OAAA,CAAA,YAAA,CAAA,GAAA,OAAA,EAAA,CADA,KAGA,IAAA,CAAA,YAAA,CAAA,GAAA,OAAA,EAAA;AACC,CATD,EASC,IATD,EASC,YAAA;AACD;;;;;;;;;;;;;;;;;;;ACVA,cAAA,OAAA,GAAA,sBAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA;;AACA,cAAA,aAAA,GAAA,sBAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA;;AAEA,cAAA,KAAA,GAAA,mBAAA,CAAA,GAAA,CAAA;;AAOA,cAAA,MAAA,GAAA,mBAAA,CAAA,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,cAAMA,aAAa,GAAnB,SAAA;AACA,cAAMC,sBAAsB,GAA5B,mBAAA;;cAEaC,U;;;;;AAEX,qBAAA,UAAA,CAAA,GAAA,EAAA,OAAA,EAA0B;AAAA,kBAAA,KAAA;;AAAA,cAAA,eAAA,CAAA,IAAA,EAAA,UAAA,CAAA;;AACxB,cAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AACA,cAAA,KAAA,CAAA,IAAA,GAAA,GAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,OAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,SAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,eAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,OAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,WAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,SAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,OAAA,GAAA,cAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,aAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,cAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,gBAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,CAAA;AACA,cAAA,KAAA,CAAA,SAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,gBAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,KAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,WAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,WAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,SAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,WAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,oBAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,gBAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,iBAAA,GAAA,CAAA;AACA,cAAA,KAAA,CAAA,eAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,YAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,YAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,mBAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,CAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,aAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,YAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,MAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,MAAA,GAAA,CAAA;AACA,cAAA,KAAA,CAAA,KAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,gBAAA,GAAwBE,OAAO,CAA/B,OAAwBA,EAAxB;AACA,cAAA,KAAA,CAAA,OAAA,GAAe;AACbC,gBAAAA,KAAK,EADQ,KAAA;AAEbC,gBAAAA,IAAI,EAFS,EAAA;AAGbC,gBAAAA,OAAO,EAHM,EAAA;AAIbC,gBAAAA,SAAS,EAJI,IAAA;AAKbC,gBAAAA,MAAM,EALO,IAAA;AAMbC,gBAAAA,cAAc,EAND,IAAA;AAObC,gBAAAA,QAAQ,EAPK,IAAA;AAQbC,gBAAAA,QAAQ,EARK,KAAA;AASbC,gBAAAA,OAAO,EATM,IAAA;AAUbC,gBAAAA,IAAI,EAVS,IAAA;AAWbC,gBAAAA,YAAY,EAXC,KAAA;AAYbC,gBAAAA,eAAe,EAZF,IAAA;AAabC,gBAAAA,oBAAoB,EAbP,GAAA;AAcbC,gBAAAA,gBAAgB,EAdH,IAAA;AAebC,gBAAAA,YAAY,EAfC,IAAA;AAgBbC,gBAAAA,gBAAgB,EAAE,CAAA,WAAA,EAAA,eAAA,EAAA,eAAA,EAAA,aAAA,EAAA,oBAAA,EAAA,iBAAA,EAAA,aAAA,EAAA,aAAA,EAAA,oBAAA,EAhBL,eAgBK,CAhBL;AA4BbC,gBAAAA,eAAe,EA5BF,qBAAA;AA6BbC,gBAAAA,cAAc,EA7BD,EAAA;AA8BbC,gBAAAA,aAAa,EA9BA,EAAA;AA+BbC,gBAAAA,WAAW,EA/BE,EAAA;AAgCbC,gBAAAA,eAAe,EAhCF,IAAA;AAiCbC,gBAAAA,eAAe,EAjCF,IAAA;AAkCbC,gBAAAA,eAAe,EAlCF,IAAA;AAmCbC,gBAAAA,SAAS,EAnCI,IAAA;AAoCbC,gBAAAA,iBAAiB,EApCJ,uBAAA;AAqCbC,gBAAAA,gBAAgB,EArCH,EAAA;AAsCbC,gBAAAA,eAAe,EAtCF,EAAA;AAuCbC,gBAAAA,kBAAkB,EAvCL,IAAA;AAwCbC,gBAAAA,kBAAkB,EAAE;AAxCP,eAAf;;AA0CA,cAAA,KAAA,CAAA,UAAA,CAAA,OAAA;;AAvFwB,qBAAA,KAAA;AAwFzB;;;;uCAEQC,K,EAAO;AACd,qBAAA,MAAA,GAAA,KAAA;AACD;;;6CAEcC,I,EAAM;AACnB,qBAAA,YAAA,GAAA,IAAA;AACD;;;gDAEiBC,O,EAAS;AACzB,qBAAA,OAAA,CAAA,cAAA,GAAA,OAAA;AACD;;;+CACgBC,M,EAAQ;AACvB,qBAAA,OAAA,CAAA,aAAA,GAAA,MAAA;AACD;;;6CACcF,I,EAAM;AACnB,qBAAA,OAAA,CAAA,WAAA,GAAA,IAAA;AACD;;;kDAEmBC,O,EAAS;AAC3B,qBAAA,OAAA,CAAA,gBAAA,GAAA,OAAA;AACD;;;iDACkBC,M,EAAQ;AACzB,qBAAA,OAAA,CAAA,eAAA,GAAA,MAAA;AACD;;;oCAEKC,G,EAAKD,M,EAAQD,O,EAASD,I,EAAMI,Q,EAAU;AAAA,oBAAA,MAAA,GAAA,IAAA;;AAC1C,oBAAIC,KAAK,GAAT,EAAA;;AACA,qBAAA,MAAA,CAAA,yBAAA,EAAA,GAAA,EAAA,WAAA,EAAyDC,IAAI,CAAJA,SAAAA,CAAzD,IAAyDA,CAAzD;;AAEA,oBAAA,GAAA;;AACA,oBAAI,KAAA,eAAA,KAAJ,IAAA,EAAmC;AACjC;AACAC,kBAAAA,GAAG,GAAG,IAAI,KAAVA,eAAM,EAANA;AAFF,iBAAA,MAGO;AACLA,kBAAAA,GAAG,GAAIC,mBAAAA,CAAAA,CAAAA,CAAAA,cAAAA,GAAwB,IAAIA,mBAAAA,CAAAA,CAAAA,CAA5BA,cAAwB,EAAxBA,GAAsD,IAAIA,mBAAAA,CAAAA,CAAAA,CAAJ,aAAA,CAA7DD,mBAA6D,CAA7DA;AACD;;AAED,qBAAK,IAAL,CAAA,IAAA,MAAA,EAAwB;AACtB,sBAAIL,MAAM,CAANA,cAAAA,CAAJ,CAAIA,CAAJ,EAA8B;AAC5B,wBAAIG,KAAK,CAALA,MAAAA,GAAJ,CAAA,EAAsB;AACpBA,sBAAAA,KAAK,IAALA,GAAAA;AACD;;AACDA,oBAAAA,KAAK,IAAII,kBAAkB,CAAlBA,CAAkB,CAAlBA,GAAAA,GAAAA,GAA8BA,kBAAkB,CAACP,MAAM,CAAhEG,CAAgE,CAAP,CAAzDA;AACD;AACF;;AACD,oBAAIA,KAAK,CAALA,MAAAA,GAAJ,CAAA,EAAsB;AACpBA,kBAAAA,KAAK,GAAG,MAARA,KAAAA;AACD;;AACDE,gBAAAA,GAAG,CAAHA,IAAAA,CAAAA,MAAAA,EAAiBJ,GAAG,GAApBI,KAAAA,EAAAA,IAAAA;;AACA,oBAAI,qBAAJ,GAAA,EAA8B;AAC5BA,kBAAAA,GAAG,CAAHA,eAAAA,GAAAA,IAAAA;AACD;;AAEDA,gBAAAA,GAAG,CAAHA,gBAAAA,CAAAA,kBAAAA,EAAAA,gBAAAA;AACAA,gBAAAA,GAAG,CAAHA,gBAAAA,CAAAA,cAAAA,EAAAA,kBAAAA;;AACA,qBAAK,IAAL,UAAA,IAAA,OAAA,EAAkC;AAChC,sBAAIN,OAAO,CAAPA,cAAAA,CAAJ,UAAIA,CAAJ,EAAwC;AACtCM,oBAAAA,GAAG,CAAHA,gBAAAA,CAAAA,UAAAA,EAAiCN,OAAO,CAAxCM,UAAwC,CAAxCA;AACD;AACF;;AAEDA,gBAAAA,GAAG,CAAHA,kBAAAA,GAAyB,YAAM;AAC7B,sBAAIA,GAAG,CAAHA,UAAAA,KAAJ,CAAA,EAA0B;AACxB,wBAAIA,GAAG,CAAHA,MAAAA,KAAJ,GAAA,EAAwB;AACtB,0BAAA,KAAA;AAAA,0BAAUG,MAAM,GAAhB,KAAA;;AACA,0BAAI;AACFV,wBAAAA,KAAI,GAAGM,IAAI,CAAJA,KAAAA,CAAWC,GAAG,CAArBP,YAAOM,CAAPN;AACAU,wBAAAA,MAAM,GAANA,IAAAA;AAFF,uBAAA,CAGE,OAAA,CAAA,EAAU;AACVN,wBAAAA,QAAQ,CAAC;AACPO,0BAAAA,KAAK,EAAE,6BAA6BJ,GAAG,CADhC,YAAA;AAEPK,0BAAAA,MAAM,EAFC,GAAA;AAGPZ,0BAAAA,IAAI,EAAE;AAHC,yBAAD,CAARI;AAKD;;AACD,0BAAA,MAAA,EAAY;AAAE;AACZA,wBAAAA,QAAQ,CAAC;AACPJ,0BAAAA,IAAI,EADG,KAAA;AAEPY,0BAAAA,MAAM,EAAE;AAFD,yBAAD,CAARR;AAID;AAjBH,qBAAA,MAkBO;AACL,sBAAA,MAAI,CAAJ,IAAA,CAAA,oCAAA,EAAgDG,GAAG,CAAnD,MAAA;;AACAH,sBAAAA,QAAQ,CAAC;AACPQ,wBAAAA,MAAM,EAAEL,GAAG,CADJ,MAAA;AAEPP,wBAAAA,IAAI,EAAE;AAFC,uBAAD,CAARI;AAID;AACF;AA3BHG,iBAAAA;;AA6BAM,gBAAAA,UAAU,CAAC,YAAA;AAAA,yBAAMN,GAAG,CAAHA,IAAAA,CAASD,IAAI,CAAJA,SAAAA,CAAf,IAAeA,CAATC,CAAN;AAAD,iBAAA,EAAVM,EAAU,CAAVA;AACA,uBAAA,GAAA;AACD;;;qCAEM;AACL,iBAAA,GAAA,MAAA,CAAA,GAAA,EAAA,MAAA,EAAA,SAAA;AACD;;;uCAEQ;AACP,oBAAI,KAAA,OAAA,CAAA,KAAA,KAAJ,IAAA,EAAiC;AAC/B,mBAAA,GAAA,MAAA,CAAA,GAAA,EAAA,OAAA,EAAA,SAAA;AACD;AACF;;;oDAEqB;AACpB,oBAAI,KAAA,OAAA,CAAA,SAAA,KAAJ,IAAA,EAAqC;AACnC,yBAAA,IAAA;AACD;;AACD,uBAAO,EAAE,OAAA,SAAA,KAAA,UAAA,IAAmC,CAAA,OAAA,SAAA,KAAA,WAAA,GAAA,WAAA,GAAA,OAAA,CAAA,SAAA,CAAA,MAA5C,QAAO,CAAP;AACD;;;yCAEUC,M,EAAQ;AACjB,oBAAI,KAAA,eAAA,CAAJ,MAAI,CAAJ,EAAkC;AAChC;AACD;;AACD,oBAAIA,MAAM,KAAV,UAAA,EAA2B;AACzB,wBAAM,IAAA,KAAA,CAAN,2EAAM,CAAN;AACD;;AACD,qBAAA,OAAA,GAAA,KAAA;AACA,qBAAA,WAAA,GAAmBC,KAAAA,CAAnB,cAAA;AACA,qBAAA,SAAA,GAAiBC,KAAAA,CAAjB,YAAA;AACA,qBAAA,QAAA,GAAgB,IAAIC,KAAAA,CAApB,WAAgB,EAAhB;AACA,qBAAA,QAAA,GAAgB,IAAIC,KAAAA,CAApB,WAAgB,EAAhB;AACD;;;8CAEeJ,M,EAAQ;AACtB,uBAAA,KAAA;AACD;;;yCAEUK,a,EAAe;AACxB,oBAAI,EAAE,aAAaX,mBAAAA,CAAnB,CAAI,CAAJ,EAA4B;AAC1B,wBAAM,IAAA,KAAA,CAAN,2BAAM,CAAN;AACD;;AAED,iBAAA,GAAA,MAAA,CAAA,MAAA,EAAO,KAAP,OAAA,EAAqBW,aAAa,IAAlC,EAAA;;AACA,qBAAA,MAAA,CAAA,mBAAA,EAAiC,KAAjC,OAAA;;AAEA,oBAAI,CAAC,KAAL,IAAA,EAAgB;AACd,wBAAM,IAAA,KAAA,CAAN,cAAM,CAAN;AACD;;AAED,oBAAI,CAAA,GAAA,MAAA,CAAA,UAAA,EAAW,KAAX,IAAA,EAAA,IAAA,KAA+B,KAAA,IAAA,CAAA,OAAA,CAAA,iBAAA,IAAuC,CAA1E,CAAA,EAA8E;AAC5E,uBAAA,UAAA,CAAA,UAAA;AADF,iBAAA,MAEO;AACL,uBAAA,UAAA,CAAA,MAAA;AACD;;AAED,oBAAI,CAAA,GAAA,MAAA,CAAA,UAAA,EAAW,KAAX,IAAA,EAAJ,MAAI,CAAJ,EAAmC;AACjC,uBAAA,MAAA,CAAA,+CAAA;;AACA,sBAAI,KAAA,OAAA,CAAA,MAAA,KAAJ,IAAA,EAAkC;AAChC,yBAAA,MAAA,CAAA,uCAAA;;AACA,yBAAA,OAAA,GAAe,KAAA,OAAA,CAAf,MAAA;AAFF,mBAAA,MAGO;AACL,wBAAI,OAAOX,mBAAAA,CAAAA,CAAAA,CAAP,MAAA,KAAJ,WAAA,EAA0C;AACxC,4BAAM,IAAA,KAAA,CAAN,sDAAM,CAAN;AACD;;AACD,yBAAA,MAAA,CAAA,6BAAA;;AACA,yBAAA,OAAA,GAAeA,mBAAAA,CAAAA,CAAAA,CAAf,MAAA;AACD;AAXH,iBAAA,MAYO;AACL,uBAAA,MAAA,CAAA,2CAAA;AACD;;AAED,qBAAA,eAAA,GAAuB,KAAA,OAAA,CAAvB,cAAA;AACD;;;yCAEUY,S,EAAW;AACpB,oBAAI,KAAA,OAAA,KAAJ,SAAA,EAAgC;AAC9B,uBAAA,MAAA,CAAA,QAAA,EAAsB,KAAtB,OAAA,EAAA,IAAA,EAAA,SAAA;;AACA,uBAAA,OAAA,GAAA,SAAA;AACD;AACF;;;gDAEiB;AAChB,uBAAO,KAAA,OAAA,KAAP,cAAA;AACD;;;8CAEe;AACd,uBAAO,KAAA,OAAA,KAAP,YAAA;AACD;;;6CAEc;AACb,uBAAO,KAAA,OAAA,KAAP,WAAA;AACD;;;+CAEgB;AACf,uBAAO,EAAE,KAAT,UAAA;AACD;;;4CAEa;AACZ,qBAAA,MAAA,CAAA,0BAAA;;AACA,qBAAA,QAAA,GAAA,CAAA;AACD;;;kDAEmB;AAClB,oBAAMC,QAAQ,GAAG,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,KAAR,QAAA,EAAuB,KAAA,OAAA,CAAvB,QAAA,EAA8C,KAAA,OAAA,CAA/D,QAAiB,CAAjB;AAEA,qBAAA,QAAA,IAAA,CAAA;AACA,uBAAA,QAAA;AACD;;;mDAEoB;AACnB,qBAAK,IAAL,KAAA,IAAoB,KAApB,KAAA,EAAgC;AAC9B,sBAAI;AACF,yBAAA,KAAA,CAAA,KAAA,EAAA,KAAA;AADF,mBAAA,CAEE,OAAA,CAAA,EAAU;AACV,yBAAA,MAAA,CAAA,oBAAA,EAAA,CAAA;AACD;;AACD,yBAAO,KAAA,KAAA,CAAP,KAAO,CAAP;AACD;AACF;;;mDAEoBC,S,EAAW;AAC9B,qBAAA,SAAA,GAAA,IAAA;;AACA,qBAF8B,SAE9B,GAF8B,CAI9B;;;AACA,qBAAK,IAAL,EAAA,IAAiB,KAAjB,UAAA,EAAkC;AAChC,sBAAI,KAAA,UAAA,CAAA,cAAA,CAAJ,EAAI,CAAJ,EAAwC;AACtC,wBAAMC,SAAS,GAAG,KAAA,UAAA,CAAlB,EAAkB,CAAlB;AACAC,oBAAAA,YAAY,CAACD,SAAS,CAAtBC,OAAY,CAAZA;AACA,wBAAMC,OAAO,GAAGF,SAAS,CAAzB,OAAA;;AACA,wBAAI,CAAJ,OAAA,EAAc;AACZ;AACD;;AACDE,oBAAAA,OAAO,CAAC;AAACd,sBAAAA,KAAK,EAAE,KAAA,kBAAA,CAAA,cAAA;AAAR,qBAAD,CAAPc;AACD;AACF;;AACD,qBAAA,UAAA,GAhB8B,EAgB9B,CAhB8B,CAkB9B;;AACA,qBAAK,IAAL,OAAA,IAAsB,KAAtB,KAAA,EAAkC;AAChC,sBAAI,KAAA,KAAA,CAAA,cAAA,CAAJ,OAAI,CAAJ,EAAwC;AACtC,wBAAMC,GAAG,GAAG,KAAA,KAAA,CAAZ,OAAY,CAAZ;;AAEA,wBAAA,SAAA,EAAe;AACb,0BAAIA,GAAG,CAAP,UAAIA,EAAJ,EAAsB;AACpBA,wBAAAA,GAAG,CAAHA,mBAAAA;;AACAA,wBAAAA,GAAG,CAAHA,QAAAA,GAAAA,IAAAA;AACD;;AACD,0BAAIA,GAAG,CAAP,kBAAIA,EAAJ,EAA8B;AAC5BA,wBAAAA,GAAG,CAAHA,eAAAA;AACD;AAPH,qBAAA,MAQO;AACLA,sBAAAA,GAAG,CAAHA,gBAAAA;AACD;AACF;AACF;;AAED,qBArC8B,kBAqC9B,GArC8B,CAuC9B;;;AACA,oBAAI,KAAA,eAAA,KAAJ,IAAA,EAAmC;AACjCF,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACA,uBAAA,eAAA,GAAA,IAAA;AA1C4B,iBAAA,CA6C9B;;;AACA,qBAAK,IAAL,QAAA,IAAsB,KAAtB,mBAAA,EAAgD;AAC9C,sBAAI,KAAA,mBAAA,CAAA,cAAA,CAAA,QAAA,KAAoD,KAAA,mBAAA,CAAxD,QAAwD,CAAxD,EAA2F;AACzF,yBAAA,uBAAA,CAAA,QAAA;AACD;AACF;;AACD,qBAAA,mBAAA,GAAA,EAAA;;AAEA,oBAAI,CAAC,KAAL,UAAA,EAAsB;AACpB;AACA,uBAAA,KAAA,GAAA,EAAA;AACD;AACF;;;iDAEkB;AACjB,oBAAI,KAAJ,SAAA,EAAoB;AAClB,yBAAO,KAAA,UAAA,IACL,KAAA,UAAA,CADK,SAAA,IAEL,KAAA,UAAA,CAAA,SAAA,CAAA,UAAA,KAAyC,KAAA,UAAA,CAAA,SAAA,CAF3C,IAAA;AAGD;;AACD,uBAAO,KAAA,UAAA,IAAmB,KAAA,UAAA,CAAA,UAAA,KAA+B,KAAA,UAAA,CAAzD,IAAA;AACD;;;6CAEcG,Q,EAAU;AACvB,oBAAI,CAACA,QAAQ,CAAb,MAAA,EAAsB;AACpB,yBAAA,IAAA;AACD;;AAED,oBAAI,CAAC,KAAL,gBAAK,EAAL,EAA8B;AAC5B;AACA,uBAAK,IAAL,OAAA,IAAA,QAAA,EAA8B;AAC5B,wBAAIC,EAAE,GAAGC,OAAO,CAAhB,EAAA;;AACA,wBAAI,EAAED,EAAE,IAAI,KAAZ,UAAI,CAAJ,EAA8B;AAC5B;AACD;;AACD,wBAAML,SAAS,GAAG,KAAA,UAAA,CAAlB,EAAkB,CAAlB;AACAC,oBAAAA,YAAY,CAAC,KAAA,UAAA,CAAA,EAAA,EAAbA,OAAY,CAAZA;AACA,2BAAO,KAAA,UAAA,CAAP,EAAO,CAAP;AACA,wBAAMC,OAAO,GAAGF,SAAS,CAAzB,OAAA;AACAE,oBAAAA,OAAO,CAAC;AAACd,sBAAAA,KAAK,EAAE,KAAA,kBAAA,CAAA,sBAAA,EAAA,CAAA;AAAR,qBAAD,CAAPc;AACD;;AACD,yBAAA,KAAA;AACD;;AACD,qBAAA,UAAA,CAAA,IAAA,CAAqB,KAAA,QAAA,CAAA,cAAA,CAArB,QAAqB,CAArB;;AACA,uBAAA,IAAA;AACD;;;gDAEiB;AAAA,oBAAA,MAAA,GAAA,IAAA;;AAChB,qBAAA,SAAA,GADgB,KAChB,CADgB,CAGhB;;AACA,oBAAI,KAAA,OAAA,KAAJ,IAAA,EAA2B;AACzB,sBAAMK,aAAa,GAAG;AACpBC,oBAAAA,UAAU,EAAE,KAAA,OAAA,CAAa9C;AADL,mBAAtB;;AAIA,sBAAI,KAAA,OAAA,CAAA,YAAA,KAAJ,IAAA,EAAwC;AACtC6C,oBAAAA,aAAa,CAAbA,MAAAA,GAAuB,KAAA,OAAA,CAAvBA,YAAAA;AACD;;AACD,uBAAA,SAAA,GAAA,IAAA;AACA,uBAAA,UAAA,GAAkB,IAAI,KAAJ,OAAA,CAAiB,KAAjB,IAAA,EAAA,IAAA,EAAlB,aAAkB,CAAlB;AATF,iBAAA,MAUO;AACL,sBAAI,CAAC,KAAL,mBAAK,EAAL,EAAiC;AAC/B,yBAAA,MAAA,CAAA,gEAAA;;AACA;AACD;;AACD,sBAAI,KAAA,OAAA,CAAA,SAAA,KAAJ,IAAA,EAAqC;AACnC,yBAAA,UAAA,GAAkB,KAAA,OAAA,CAAlB,SAAA;AADF,mBAAA,MAEO;AACL,yBAAA,UAAA,GAAA,SAAA;AACD;;AACD,uBAAA,UAAA,GAAkB,IAAI,KAAJ,UAAA,CAAoB,KAAtC,IAAkB,CAAlB;;AACA,sBAAI,KAAA,OAAA,KAAJ,IAAA,EAA2B;AACzB,yBAAA,UAAA,CAAA,UAAA,GAAA,aAAA;AACD;AACF;;AAED,qBAAA,UAAA,CAAA,MAAA,GAAyB,YAAM;AAC7B,kBAAA,MAAI,CAAJ,gBAAA,GAAA,KAAA;;AAEA,sBAAI,MAAI,CAAR,SAAA,EAAoB;AAClB,oBAAA,MAAI,CAAJ,cAAA,GAAsB,YAAY,MAAI,CAAJ,UAAA,CAAlC,SAAA;;AACA,oBAAA,MAAI,CAAJ,UAAA,CAAA,WAAA,GAA8B,YAAA;AAAA,6BAAM,MAAI,CAAV,YAAM,EAAN;AAA9B,qBAAA;AAFF,mBAAA,MAGO;AACL,oBAAA,MAAI,CAAJ,cAAA,GAAA,WAAA;AAP2B,mBAAA,CAU7B;;;AACA,sBAAME,GAAG,GAAG,CACV;AADU,mBAAZ;;AAIA,sBAAI,MAAI,CAAJ,MAAA,IAAe,MAAI,CAAnB,YAAA,IAAoC,MAAI,CAAJ,OAAA,CAApC,IAAA,IAAyD,MAAI,CAAJ,OAAA,CAA7D,OAAA,EAAmF;AACjFA,oBAAAA,GAAG,CAAHA,MAAAA,GAAAA,EAAAA;AACD;;AACD,sBAAI,MAAI,CAAR,MAAA,EAAiB;AACfA,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,KAAAA,GAAmB,MAAI,CAAvBA,MAAAA;AACD;;AACD,sBAAI,MAAI,CAAR,YAAA,EAAuB;AACrBA,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,IAAAA,GAAkB,MAAI,CAAtBA,YAAAA;AACD;;AACD,sBAAI,MAAI,CAAJ,OAAA,CAAJ,IAAA,EAAuB;AACrBA,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,IAAAA,GAAkB,MAAI,CAAJ,OAAA,CAAlBA,IAAAA;AACD;;AACD,sBAAI,MAAI,CAAJ,OAAA,CAAJ,OAAA,EAA0B;AACxBA,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,OAAAA,GAAqB,MAAI,CAAJ,OAAA,CAArBA,OAAAA;AACD;;AAED,sBAAIC,IAAI,GAAR,EAAA;AACA,sBAAIC,OAAO,GAAX,KAAA;;AACA,uBAAK,IAAL,OAAA,IAAsB,MAAI,CAA1B,WAAA,EAAwC;AACtC,wBAAI,MAAI,CAAJ,WAAA,CAAA,cAAA,CAAA,OAAA,KAA4C,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAhD,WAAA,EAAuF;AACrFA,sBAAAA,OAAO,GAAPA,IAAAA;AACA,0BAAIR,GAAG,GAAG;AACR,mCAAW;AADH,uBAAV;;AAGA,0BAAI,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAA,GAAA,IAAiC,MAAI,CAAJ,WAAA,CAAA,OAAA,EAArC,GAAA,EAAoE;AAClE,4BAAI,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAJ,GAAA,EAAmC;AACjCA,0BAAAA,GAAG,CAAHA,KAAG,CAAHA,GAAa,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAbA,GAAAA;AACD;;AACD,4BAAI,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAJ,GAAA,EAAmC;AACjCA,0BAAAA,GAAG,CAAHA,KAAG,CAAHA,GAAa,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAbA,GAAAA;AACD;AANH,uBAAA,MAOO;AACL,4BAAI,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAJ,MAAA,EAAsC;AACpCA,0BAAAA,GAAG,CAAHA,QAAG,CAAHA,GAAgB,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAhBA,MAAAA;AACD;AACF;;AACD,0BAAI,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAJ,KAAA,EAAqC;AACnCA,wBAAAA,GAAG,CAAHA,OAAG,CAAHA,GAAe,MAAI,CAAJ,WAAA,CAAA,OAAA,EAAfA,KAAAA;AACD;;AACDO,sBAAAA,IAAI,CAAJA,OAAI,CAAJA,GAAAA,GAAAA;AACD;AACF;;AACD,sBAAA,OAAA,EAAa;AACX,wBAAI,CAACD,GAAG,CAAR,MAAA,EAAiB;AAACA,sBAAAA,GAAG,CAAHA,MAAAA,GAAAA,EAAAA;AAAiB;;AACnCA,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,IAAAA,GAAAA,IAAAA;AACD;;AAED,kBAAA,MAAI,CAAJ,aAAA,GAAqB,IAArB,IAAqB,EAArB;;AACA,kBAAA,MAAI,CAAJ,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,oBAAA,MAAI,CAAJ,gBAAA,CAAsB,MAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,MAAI,CAAJ,WAAA,CAAlC,OAAA,EAA4DG,UAAU,CAA5F,MAAsB,CAAtB,EAAA,OAAA;;AACA,wBAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,sBAAAA,UAAU,CAAVA,IAAAA;AACD;AAJH,mBAAA,EAKG,UAAA,SAAA,EAAa;AACd,wBAAMC,GAAG,GAAGC,SAAS,CAArB,KAAA;;AACA,wBAAID,GAAG,CAAHA,IAAAA,KAAJ,GAAA,EAAsB;AAAE;AACtB,sBAAA,MAAI,CAAJ,gBAAA,GAAA,IAAA;AACD;;AACD,oBAAA,MAAI,CAAJ,WAAA,CAAA,eAAA,EAAA,IAAA;;AACA,wBAAIC,SAAS,CAAb,IAAA,EAAoB;AAClBA,sBAAAA,SAAS,CAATA,IAAAA;AACD;AAbH,mBAAA;AA/DF,iBAAA;;AAgFA,qBAAA,UAAA,CAAA,OAAA,GAA0B,UAAA,KAAA,EAAS;AACjC,kBAAA,MAAI,CAAJ,MAAA,CAAA,uBAAA,EAAA,KAAA;AADF,iBAAA;;AAIA,qBAAA,UAAA,CAAA,OAAA,GAA0B,UAAA,UAAA,EAAc;AACtC,kBAAA,MAAI,CAAJ,gBAAA,GAAA,IAAA;AACA,sBAAIC,MAAM,GAAV,sBAAA;AACA,sBAAIC,aAAa,GAAjB,IAAA;;AAEA,sBAAIC,UAAU,IAAI,YAAdA,UAAAA,IAAwCA,UAAU,CAAtD,MAAA,EAA+D;AAC7D,wBAAI;AACF,0BAAMC,MAAM,GAAGnC,IAAI,CAAJA,KAAAA,CAAWkC,UAAU,CAApC,MAAelC,CAAf;;AACA,sBAAA,MAAI,CAAJ,MAAA,CAAA,4BAAA,EAAA,MAAA;;AACAgC,sBAAAA,MAAM,GAAGG,MAAM,CAAfH,MAAAA;AACAC,sBAAAA,aAAa,GAAGE,MAAM,CAAtBF,SAAAA;AAJF,qBAAA,CAKE,OAAA,CAAA,EAAU;AACVD,sBAAAA,MAAM,GAAGE,UAAU,CAAnBF,MAAAA;;AACA,sBAAA,MAAI,CAAJ,MAAA,CAAA,0BAAA,EAAA,MAAA;AACD;AAdmC,mBAAA,CAiBtC;AACA;AACA;AACA;;;AACA,sBAAI,MAAI,CAAJ,OAAA,CAAA,gBAAA,KAAJ,IAAA,EAA4C;AAC1C,oBAAA,MAAI,CAAJ,OAAA,CAAA,gBAAA,CAA8B;AAC5BI,sBAAAA,KAAK,EADuB,UAAA;AAE5BJ,sBAAAA,MAAM,EAFsB,MAAA;AAG5BhB,sBAAAA,SAAS,EAAEiB;AAHiB,qBAA9B;AAKD;;AAED,kBAAA,MAAI,CAAJ,WAAA,CAAA,MAAA,EAAA,aAAA;;AAEA,sBAAI,MAAI,CAAJ,UAAA,KAAJ,IAAA,EAA8B;AAC5B,oBAAA,MAAI,CAAJ,aAAA,GAAA,IAAA;;AACA,wBAAMlB,QAAQ,GAAG,MAAI,CAArB,iBAAiB,EAAjB;;AAEA,oBAAA,MAAI,CAAJ,MAAA,CAAY,qBAAA,QAAA,GAAZ,eAAA;;AACAR,oBAAAA,UAAU,CAAC,YAAM;AACf,0BAAI,MAAI,CAAJ,UAAA,KAAJ,IAAA,EAA8B;AAC5B,4BAAI,MAAI,CAAR,gBAAA,EAA2B;AACzB,0BAAA,MAAI,CAAJ,QAAA;AADF,yBAAA,MAEO;AACL,0BAAA,MAAI,CAAJ,QAAA;AACD;AACF;AAPO,qBAAA,EAAVA,QAAU,CAAVA;AASD;AA7CH,iBAAA;;AAgDA,qBAAA,UAAA,CAAA,SAAA,GAA4B,UAAA,KAAA,EAAS;AACnC,kBAAA,MAAI,CAAJ,aAAA,CAAmB6B,KAAK,CAAxB,IAAA;AADF,iBAAA;AAGD;;;kCAEG1C,I,EAAM;AACR,uBAAO,KAAA,IAAA,CAAA,EAAA,EAAP,IAAO,CAAP;AACD;;;uCAEQ2C,M,EAAQ3C,I,EAAM;AACrB,uBAAO,KAAA,IAAA,CAAA,MAAA,EAAP,IAAO,CAAP;AACD;;;mCAEI2C,M,EAAQ3C,I,EAAM;AACjB,oBAAIE,MAAM,GAAG;AACXF,kBAAAA,IAAI,EAAEA;AADK,iBAAb;;AAGA,oBAAI2C,MAAM,KAAV,EAAA,EAAmB;AACjBzC,kBAAAA,MAAM,CAANA,MAAAA,GAAAA,MAAAA;AACD;;AAAA;AACD,oBAAM8B,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,GAAA;AAEVzC,kBAAAA,MAAM,EAAEA;AAFE,iBAAZ;AAIA,uBAAO,KAAA,WAAA,CAAA,GAAA,EAAsB,UAAA,MAAA,EAAkB;AAC7C,yBAAA,MAAA;AADF,iBAAO,CAAP;AAGD;;;mCAEIF,I,EAAM;AACT,oBAAMgC,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,IAAA;AAEVzC,kBAAAA,MAAM,EAAE;AACNF,oBAAAA,IAAI,EAAEA;AADA;AAFE,iBAAZ;;AAOA,oBAAI,CAAC,KAAL,WAAK,EAAL,EAAyB;AACvB,yBAAO/B,OAAO,CAAPA,MAAAA,CAAe,KAAA,kBAAA,CAAA,sBAAA,EAAtB,CAAsB,CAAfA,CAAP;AACD;;AAED,oBAAM2E,IAAI,GAAG,KAAA,cAAA,CAAoB,CAZxB,GAYwB,CAApB,CAAb,CAZS,CAYgC;;;AACzC,oBAAI,CAAJ,IAAA,EAAW;AACT,yBAAO3E,OAAO,CAAPA,MAAAA,CAAe,KAAA,kBAAA,CAAA,sBAAA,EAAtB,CAAsB,CAAfA,CAAP;AACD;;AAAA;AACD,uBAAOA,OAAO,CAAPA,OAAAA,CAAP,EAAOA,CAAP;AACD;;;gDAEiB4E,O,EAASC,O,EAAS;AAClC,oBAAI5C,MAAM,GAAG;AACX2C,kBAAAA,OAAO,EAAEA;AADE,iBAAb;;AAGA,oBAAIC,OAAO,KAAX,SAAA,EAA2B;AACzB,sBAAIA,OAAO,CAAX,KAAA,EAAmB;AACjB5C,oBAAAA,MAAM,CAANA,WAAM,CAANA,GAAAA,IAAAA;;AACA,wBAAI4C,OAAO,CAAPA,KAAAA,CAAJ,MAAA,EAA0B;AACxB5C,sBAAAA,MAAM,CAANA,QAAM,CAANA,GAAmB4C,OAAO,CAAPA,KAAAA,CAAnB5C,MAAAA;AACD;;AACD,wBAAI4C,OAAO,CAAPA,KAAAA,CAAJ,KAAA,EAAyB;AACvB5C,sBAAAA,MAAM,CAANA,OAAM,CAANA,GAAkB4C,OAAO,CAAPA,KAAAA,CAAlB5C,KAAAA;AACD;AACF;;AAAA;;AACD,sBAAI4C,OAAO,CAAPA,KAAAA,KAAJ,SAAA,EAAiC;AAC/B5C,oBAAAA,MAAM,CAANA,WAAM,CAANA,GAAAA,IAAAA;AACAA,oBAAAA,MAAM,CAANA,OAAM,CAANA,GAAkB4C,OAAO,CAAzB5C,KAAAA;AACD;AACF;;AAAA;AACD,uBAAA,MAAA;AACD;;;0CAEW8B,G,EAAKe,Q,EAAU;AAAA,oBAAA,MAAA,GAAA,IAAA;;AACzB,oBAAI,CAAC,KAAL,WAAK,EAAL,EAAyB;AACvB,yBAAO9E,OAAO,CAAPA,MAAAA,CAAe,KAAA,kBAAA,CAAA,sBAAA,EAAtB,CAAsB,CAAfA,CAAP;AACD;;AACD,uBAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AACtC,kBAAA,MAAI,CAAJ,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC+E,oBAAAA,OAAO,CAACD,QAAQ,CAAC,MAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkCf,GAAG,CAArC,MAAA,EAA8CG,UAAU,CAAzEa,MAAiB,CAAD,CAAT,CAAPA;;AACA,wBAAIb,UAAU,CAAd,IAAA,EAAqB;AACnBA,sBAAAA,UAAU,CAAVA,IAAAA;AACD;AAJH,mBAAA,EAKG,UAAA,SAAA,EAAa;AACdc,oBAAAA,MAAM,CAACZ,SAAS,CAAhBY,KAAM,CAANA;;AACA,wBAAIZ,SAAS,CAAb,IAAA,EAAoB;AAClBA,sBAAAA,SAAS,CAATA,IAAAA;AACD;AATH,mBAAA;AADF,iBAAO,CAAP;AAaD;;;sCAEOQ,O,EAAS7C,I,EAAM;AACrB,oBAAMgC,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,OAAA;AAEVzC,kBAAAA,MAAM,EAAE;AACN2C,oBAAAA,OAAO,EADD,OAAA;AAEN7C,oBAAAA,IAAI,EAAEA;AAFA;AAFE,iBAAZ;AAOA,uBAAO,KAAA,WAAA,CAAA,GAAA,EAAsB,YAAY;AACvC,yBAAA,EAAA;AADF,iBAAO,CAAP;AAGD;;;sCAEO6C,O,EAASC,O,EAAS;AACxB,oBAAM5C,MAAM,GAAG,KAAA,iBAAA,CAAA,OAAA,EAAf,OAAe,CAAf;;AACA,oBAAM8B,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,OAAA;AAEVzC,kBAAAA,MAAM,EAAEA;AAFE,iBAAZ;AAIA,uBAAO,KAAA,WAAA,CAAA,GAAA,EAAsB,UAAA,MAAA,EAAkB;AAC7C,yBAAO;AACL,oCAAgBgD,MAAM,CADjB,YAAA;AAEL,6BAASA,MAAM,CAANA,KAAAA,IAFJ,EAAA;AAGL,8BAAUA,MAAM,CAANA,MAAAA,IAAiB;AAHtB,mBAAP;AADF,iBAAO,CAAP;AAOD;;;uCAEQL,O,EAAS;AAChB,oBAAMb,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,QAAA;AAEVzC,kBAAAA,MAAM,EAAE;AACN2C,oBAAAA,OAAO,EAAEA;AADH;AAFE,iBAAZ;AAMA,uBAAO,KAAA,WAAA,CAAA,GAAA,EAAsB,UAAA,MAAA,EAAkB;AAC7C,yBAAO;AACL,gCAAYK,MAAM,CAACC;AADd,mBAAP;AADF,iBAAO,CAAP;AAKD;;;4CAEaN,O,EAAS;AACrB,oBAAMb,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,cAAA;AAEVzC,kBAAAA,MAAM,EAAE;AACN2C,oBAAAA,OAAO,EAAEA;AADH;AAFE,iBAAZ;AAMA,uBAAO,KAAA,WAAA,CAAA,GAAA,EAAsB,UAAA,MAAA,EAAkB;AAC7C,yBAAO;AACL,iCAAaK,MAAM,CADd,SAAA;AAEL,mCAAeA,MAAM,CAACE;AAFjB,mBAAP;AADF,iBAAO,CAAP;AAMD;;;4CAEapD,I,EAAM;AAAA,oBAAA,MAAA,GAAA,IAAA;;AAClB,oBAAMqD,OAAO,GAAG,KAAA,QAAA,CAAA,aAAA,CADE,IACF,CAAhB,CADkB,CAElB;AACA;AACA;AACA;;;AACA,qBAAA,gBAAA,GAAwB,KAAA,gBAAA,CAAA,IAAA,CAA2B,YAAM;AACvD,sBAAA,cAAA;AACA,kBAAA,MAAI,CAAJ,gBAAA,GAAwB,IAAA,OAAA,CAAY,UAAA,OAAA,EAAU;AAC5CC,oBAAAA,cAAc,GAAdA,OAAAA;AADF,mBAAwB,CAAxB;;AAGA,kBAAA,MAAI,CAAJ,qBAAA,CAAA,OAAA,EAAA,cAAA;AALF,iBAAwB,CAAxB;;AAOA,qBAAA,YAAA;AACD;;;oDAEqBD,O,EAASC,c,EAAgB;AAAA,oBAAA,MAAA,GAAA,IAAA;;AAC7C,oBAAIC,CAAC,GAAGtF,OAAO,CAAf,OAAQA,EAAR;;AAD6C,oBAAA,KAAA,GAAA,SAAA,KAAA,CAAA,CAAA,EAAA;AAG3C,sBAAIoF,OAAO,CAAPA,cAAAA,CAAJ,CAAIA,CAAJ,EAA+B;AAC7BE,oBAAAA,CAAC,GAAG,CAAC,CAAD,IAAA,CAAO,YAAM;AACf,6BAAO,MAAI,CAAJ,cAAA,CAAoBF,OAAO,CAAlC,CAAkC,CAA3B,CAAP;AADFE,qBAAI,CAAJA;AAGD;AAP0C,iBAAA;;AAE7C,qBAAK,IAAL,CAAA,IAAA,OAAA,EAAyB;AAAA,kBAAA,KAAA,CAAdC,CAAc,CAAA;AAMxB;;AACDD,gBAAAA,CAAC,GAAG,CAAC,CAAD,IAAA,CAAO,YAAM;AACfD,kBAAAA,cAAc;AADhBC,iBAAI,CAAJA;AAGD;;;6CAEcE,K,EAAO;AACpB,oBAAA,IAAA;AACA,oBAAMF,CAAC,GAAG,IAAA,OAAA,CAAY,UAAA,OAAA,EAAU;AAC9BG,kBAAAA,IAAI,GAAJA,OAAAA;AADF,iBAAU,CAAV;;AAIA,oBAAID,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAAhC,IAAA,EAA2C;AACzC,uBAAA,MAAA,CAAA,uCAAA;;AACAC,kBAAAA,IAAI;AACJ,yBAAA,CAAA;AACD;;AAED,oBAAM9B,EAAE,GAAG6B,KAAK,CAAhB,EAAA;;AAEA,oBAAI7B,EAAE,IAAIA,EAAE,GAAZ,CAAA,EAAkB;AAChB,uBAAA,YAAA,CAAA,KAAA,EAAA,IAAA;AADF,iBAAA,MAEO;AACL,uBAAA,WAAA,CAAiB6B,KAAK,CAAtB,MAAA,EAAA,IAAA;AACD;;AAED,uBAAA,CAAA;AACD;;;oCAEKzB,G,EAAK;AAAA,oBAAA,MAAA,GAAA,IAAA;;AACT,uBAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AACtC,sBAAMJ,EAAE,GAAG,MAAI,CAAJ,WAAA,CAAX,GAAW,CAAX;;AACA,kBAAA,MAAI,CAAJ,aAAA,CAAA,EAAA,EAAA,OAAA,EAAA,MAAA;AAFF,iBAAO,CAAP;AAID;;;yCAEU;AACT,oBAAI,KAAJ,WAAI,EAAJ,EAAwB;AACtB,uBAAA,MAAA,CAAA,uCAAA;;AACA;AACD;;AACD,oBAAI,KAAA,OAAA,KAAJ,YAAA,EAAmC;AACjC;AACD;;AAED,qBAAA,MAAA,CAAA,kBAAA;;AACA,qBAAA,UAAA,CAAA,YAAA;;AACA,qBAAA,SAAA,GAAA,IAAA;AACA,qBAAA,UAAA,GAAA,IAAA;;AACA,qBAAA,eAAA;AACD;;;0CAEWU,M,EAAQqB,e,EAAiB;AAEnC,oBAAMrC,SAAS,GAAGqC,eAAe,IAAjC,KAAA;;AACA,oBAAIrC,SAAS,KAAb,KAAA,EAAyB;AACvB,uBAAA,UAAA,GAAA,KAAA;AACD;;AAED,oBAAI,KAAJ,eAAI,EAAJ,EAA4B;AAC1B,sBAAI,CAAJ,SAAA,EAAgB;AACd,yBAAA,oBAAA,CAAA,SAAA;AACD;;AACD;AACD;;AAED,qBAAA,oBAAA,CAAA,SAAA;;AAEA,qBAAA,MAAA,CAAA,eAAA,EAAA,MAAA,EAAA,eAAA;;AACA,qBAAA,UAAA,CAAA,cAAA;;AAEA,oBAAI,KAAJ,eAAA,EAA0B;AACxBE,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACA,uBAAA,eAAA,GAAA,IAAA;AACD;;AACD,oBAAI,KAAA,aAAA,KAAJ,KAAA,EAAkC;AAChC;AACA,uBAAK,IAAL,OAAA,IAAsB,KAAtB,WAAA,EAAwC;AACtC,wBAAI,KAAA,WAAA,CAAA,cAAA,CAAJ,OAAI,CAAJ,EAA8C;AAC5C,2BAAA,IAAA,CAAA,aAAA,EAAyB;AAACqB,wBAAAA,OAAO,EAAEA;AAAV,uBAAzB;AACD;AACF;;AACD,uBAAA,IAAA,CAAA,YAAA,EAAwB;AACtBP,oBAAAA,MAAM,EADgB,MAAA;AAEtBhB,oBAAAA,SAAS,EAAEA;AAFW,mBAAxB;AAID;;AAED,oBAAIA,SAAS,KAAb,KAAA,EAAyB;AACvB,uBAAA,KAAA,GAAA,EAAA;AACA,uBAAA,WAAA,GAAA,EAAA;AACD;;AAED,oBAAI,CAAC,KAAL,gBAAA,EAA4B;AAC1B,uBAAA,UAAA,CAAA,KAAA;AACD;AACF;;;+CAEgB;AACf,qBAAA,iBAAA,GAAA,CAAA;;AACA,oBAAI,CAAC,KAAL,eAAK,EAAL,EAA6B;AAC3B,uBAAA,WAAA,CAAA,gBAAA,EAAA,KAAA;AACD;;AACD,oBAAI,KAAA,OAAA,CAAA,eAAA,KAAJ,IAAA,EAA2C;AACzC,uBAAA,OAAA,CAAA,eAAA;AACD;AACF;;;yCAEU;AAAA,oBAAA,MAAA,GAAA,IAAA,CAAA,CACT;;;AACA,qBAAA,MAAA,CAAA,eAAA;;AAEA,oBAAI,KAAA,OAAA,CAAA,eAAA,KAAJ,CAAA,EAAwC;AACtC,uBAAA,MAAA,CAAA,+DAAA;;AACA,uBAAA,cAAA;;AACA;AACD;;AAED,oBAAI,KAAA,eAAA,KAAJ,IAAA,EAAmC;AACjCE,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACA,uBAAA,eAAA,GAAA,IAAA;AACD;;AAED,oBAAMoC,QAAQ,GAAG,KAAjB,SAAA;;AACA,oBAAMC,KAAK,GAAG,KAAd,SAAc,EAAd;;AAEA,oBAAMC,EAAE,GAAG,SAALA,EAAK,CAAA,IAAA,EAAU;AACnB,sBAAID,KAAK,IAAI,MAAI,CAAjB,KAAA,EAAyB;AACvB,2BAAO,MAAI,CAAJ,KAAA,CAAP,KAAO,CAAP;AACD;;AACD,sBAAI,MAAI,CAAJ,SAAA,KAAJ,QAAA,EAAiC;AAC/B;AACD;;AACD,sBAAIE,IAAI,CAAJA,KAAAA,IAAcA,IAAI,CAAJA,MAAAA,KAAlB,GAAA,EAAuC;AACrC;AACA;AACA,wBAAIA,IAAI,CAAR,KAAA,EAAgB;AACd,sBAAA,MAAI,CAAJ,MAAA,CAAA,mCAAA,EAAiDA,IAAI,CAArD,KAAA;AADF,qBAAA,MAEO;AACL,sBAAA,MAAI,CAAJ,MAAA,CAAA,sDAAA,EAAoEA,IAAI,CAAxE,MAAA;AACD;;AACD,oBAAA,MAAI,CAAJ,iBAAA;;AACA,wBAAI,MAAI,CAAJ,eAAA,KAAJ,IAAA,EAAmC;AACjCvC,sBAAAA,YAAY,CAAC,MAAI,CAAjBA,eAAY,CAAZA;AACA,sBAAA,MAAI,CAAJ,eAAA,GAAA,IAAA;AACD;;AACD,wBAAI,MAAI,CAAJ,OAAA,CAAA,eAAA,KAAA,IAAA,IAAyC,MAAI,CAAJ,iBAAA,IAA0B,MAAI,CAAJ,OAAA,CAAvE,eAAA,EAAqG;AACnG,sBAAA,MAAI,CAAJ,cAAA;;AACA;AACD;;AACD,wBAAMwC,MAAM,GAAGC,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,MAAAA,KAAAA,IAAAA,GAAuBA,IAAI,CAAJA,GAAAA,CAAS,MAAI,CAAbA,iBAAAA,EAAjD,EAAiDA,CAAlCA,CAAf;AACA,wBAAM5C,QAAQ,GAAG,MAAI,CAAJ,OAAA,CAAA,eAAA,GAAjB,MAAA;AACA,oBAAA,MAAI,CAAJ,eAAA,GAAuBR,UAAU,CAAC,YAAA;AAAA,6BAAM,MAAI,CAAV,QAAM,EAAN;AAAD,qBAAA,EAAjC,QAAiC,CAAjC;AACA;AACD;;AACD,kBAAA,MAAI,CAAJ,iBAAA,GAAA,CAAA;AACA,kBAAA,MAAI,CAAJ,MAAA,GAAckD,IAAI,CAAJA,IAAAA,CAAd,KAAA;;AACA,sBAAI,CAAC,MAAI,CAAT,MAAA,EAAkB;AAChB,oBAAA,MAAI,CAAJ,cAAA;;AACA;AACD;;AACD,sBAAI,MAAI,CAAJ,eAAA,MAA0B,MAAI,CAAlC,UAAA,EAA+C;AAC7C,oBAAA,MAAI,CAAJ,MAAA,CAAA,uCAAA;;AACA,oBAAA,MAAI,CAAJ,QAAA;AAFF,mBAAA,MAGO;AACL,oBAAA,MAAI,CAAJ,MAAA,CAAA,sBAAA;;AACA,wBAAM/B,GAAG,GAAG;AACVW,sBAAAA,MAAM,EAAE,MAAI,CAAJ,WAAA,CADE,OAAA;AAEVzC,sBAAAA,MAAM,EAAE;AACNH,wBAAAA,KAAK,EAAE,MAAI,CAACmE;AADN;AAFE,qBAAZ;;AAMA,oBAAA,MAAI,CAAJ,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,sBAAA,MAAI,CAAJ,gBAAA,CAAsB,MAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,MAAI,CAAJ,WAAA,CAAlC,OAAA,EAA4D/B,UAAU,CAA5F,MAAsB,CAAtB;;AACA,0BAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,wBAAAA,UAAU,CAAVA,IAAAA;AACD;AAJH,qBAAA,EAKG,UAAA,SAAA,EAAa;AACd,sBAAA,MAAI,CAAJ,aAAA,CAAmBE,SAAS,CAA5B,KAAA;;AACA,0BAAIA,SAAS,CAAb,IAAA,EAAoB;AAClBA,wBAAAA,SAAS,CAATA,IAAAA;AACD;AATH,qBAAA;AAWD;AAzDH,iBAAA;;AA4DA,oBAAI,KAAA,OAAA,CAAA,SAAA,KAAJ,IAAA,EAAqC;AACnC,sBAAM8B,OAAO,GAAb,EAAA;;AACA,uBAAA,OAAA,CAAA,SAAA,CAAA,OAAA,EAAA,EAAA;AAFF,iBAAA,MAGO;AACL,sBAAM5D,GAAG,GAAG,KAAA,KAAA,CACV,KAAA,OAAA,CADU,eAAA,EAEV,KAAA,OAAA,CAFU,aAAA,EAGV,KAAA,OAAA,CAHU,cAAA,EAIV,KAAA,OAAA,CAJU,WAAA,EAAZ,EAAY,CAAZ;;AAOA,uBAAA,KAAA,CAAA,KAAA,IAAA,GAAA;AACD;AACF;;;4CAEa6B,G,EAAK;AAAA,oBAAA,MAAA,GAAA,IAAA;;AACjB,qBAAA,MAAA,CAAA,eAAA,EAAA,GAAA;;AACA,oBAAI,KAAJ,eAAA,EAA0B;AACxBZ,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACA,uBAAA,eAAA,GAAA,IAAA;AACD;;AACD,oBAAMH,QAAQ,GAAG,KAAA,OAAA,CAAA,eAAA,GAA+B4C,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,MAAAA,KAA3D,IAAgDA,CAAhD;AACA,qBAAA,eAAA,GAAuBpD,UAAU,CAAC,YAAA;AAAA,yBAAM,MAAI,CAAV,QAAM,EAAN;AAAD,iBAAA,EAAjC,QAAiC,CAAjC;AACD;;;+CAEgBqC,M,EAAQ;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACvB,oBAAI,KAAJ,eAAA,EAA0B;AACxB1B,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACA,uBAAA,eAAA,GAAA,IAAA;AACD;;AACD,oBAAI0B,MAAM,CAAV,OAAA,EAAoB;AAClB,uBAAA,SAAA,GAAiBA,MAAM,CAAvB,MAAA;AACA,uBAAA,eAAA,GAAuBrC,UAAU,CAAC,YAAA;AAAA,2BAAM,OAAI,CAAV,QAAM,EAAN;AAAD,mBAAA,EAAwB,KAAA,mBAAA,CAAyBqC,MAAM,CAAxF,GAAyD,CAAxB,CAAjC;AACD;AACF;;;0CAEW;AACV,qBAAA,MAAA;AACA,uBAAO,KAAP,MAAA;AACD;;;0CAEWL,O,EAAS;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACnB,qBAAA,MAAA,CAAA,wCAAA,EAAA,OAAA;;AAEA,oBAAI,KAAA,mBAAA,CAAA,OAAA,MAAJ,SAAA,EAAqD;AACnD,uBAAA,uBAAA,CAAA,OAAA;AADF,iBAAA,MAEO;AACL;AACD;;AAED,oBAAMe,QAAQ,GAAG,KAAjB,SAAA;;AACA,oBAAMC,KAAK,GAAG,KAAd,SAAc,EAAd;;AAEA,oBAAMC,EAAE,GAAG,SAALA,EAAK,CAAA,IAAA,EAAU;AACnB,sBAAID,KAAK,IAAI,OAAI,CAAjB,KAAA,EAAyB;AACvB,2BAAO,OAAI,CAAJ,KAAA,CAAP,KAAO,CAAP;AACD;;AACD,sBAAIE,IAAI,CAAJA,KAAAA,IAAcA,IAAI,CAAJA,MAAAA,KAAdA,GAAAA,IAAqC,OAAI,CAAJ,SAAA,KAAzC,QAAA,EAAsE;AACpE;AACD;;AACD,sBAAIK,YAAY,GAAhB,EAAA;;AACA,sBAAIL,IAAI,CAAJA,IAAAA,CAAJ,QAAA,EAAwB;AACtB,yBAAK,IAAL,CAAA,IAAgBA,IAAI,CAAJA,IAAAA,CAAhB,QAAA,EAAoC;AAClC,0BAAMM,WAAW,GAAGN,IAAI,CAAJA,IAAAA,CAAAA,QAAAA,CAApB,CAAoBA,CAApB;;AACA,0BAAI,CAACM,WAAW,CAAhB,OAAA,EAA0B;AACxB;AACD;;AACDD,sBAAAA,YAAY,CAACC,WAAW,CAAxBD,OAAY,CAAZA,GAAoCC,WAAW,CAA/CD,KAAAA;AACD;AACF;;AAED,sBAAMrE,KAAK,GAAGqE,YAAY,CAA1B,OAA0B,CAA1B;;AACA,sBAAI,CAAJ,KAAA,EAAY;AACV;AACD;;AACD,sBAAMpC,GAAG,GAAG;AACVW,oBAAAA,MAAM,EAAE,OAAI,CAAJ,WAAA,CADE,WAAA;AAEVzC,oBAAAA,MAAM,EAAE;AACN2C,sBAAAA,OAAO,EADD,OAAA;AAEN9C,sBAAAA,KAAK,EAAEA;AAFD;AAFE,mBAAZ;;AAQA,sBAAM2B,GAAG,GAAG,OAAI,CAAJ,OAAA,CAAZ,OAAY,CAAZ;;AACA,sBAAIA,GAAG,KAAP,IAAA,EAAkB;AAChB;AACD;;AAED,kBAAA,OAAI,CAAJ,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,oBAAA,OAAI,CAAJ,mBAAA,CAAA,OAAA,EAEE,OAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,OAAI,CAAJ,WAAA,CAAlC,WAAA,EAAgES,UAAU,CAF5E,MAEE,CAFF;;AAIA,wBAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,sBAAAA,UAAU,CAAVA,IAAAA;AACD;AAPH,mBAAA,EAQG,UAAA,SAAA,EAAa;AACd,oBAAA,OAAI,CAAJ,gBAAA,CAAA,OAAA,EAA+BE,SAAS,CAAxC,KAAA;;AACA,wBAAIA,SAAS,CAAb,IAAA,EAAoB;AAClBA,sBAAAA,SAAS,CAATA,IAAAA;AACD;AAZH,mBAAA;AAnCF,iBAAA;;AAmDA,oBAAMrC,IAAI,GAAG;AACXsE,kBAAAA,MAAM,EAAE,KADG,SAAA;AAEXC,kBAAAA,QAAQ,EAAE,CAAA,OAAA;AAFC,iBAAb;;AAKA,oBAAI,KAAA,OAAA,CAAA,kBAAA,KAAJ,IAAA,EAA8C;AAC5C,uBAAA,OAAA,CAAA,kBAAA,CAAgC;AAC9BvE,oBAAAA,IAAI,EAAEA;AADwB,mBAAhC,EAAA,EAAA;AADF,iBAAA,MAIO;AACL,sBAAMO,GAAG,GAAG,KAAA,KAAA,CACV,KAAA,OAAA,CADU,iBAAA,EACsB,KAAA,OAAA,CADtB,eAAA,EACoD,KAAA,OAAA,CADpD,gBAAA,EAAA,IAAA,EAAZ,EAAY,CAAZ;;AAEA,uBAAA,KAAA,CAAA,KAAA,IAAA,GAAA;AACD;AACF;;;sDAEuBsC,O,EAAS;AAC/B,oBAAI,KAAA,mBAAA,CAAA,OAAA,MAAJ,SAAA,EAAqD;AACnDrB,kBAAAA,YAAY,CAAC,KAAA,mBAAA,CAAbA,OAAa,CAAD,CAAZA;AACA,yBAAO,KAAA,mBAAA,CAAP,OAAO,CAAP;AACD;AACF;;;+CAEgBqB,O,EAAST,G,EAAK;AAAA,oBAAA,OAAA,GAAA,IAAA;;AAC7B,qBAAA,MAAA,CAAA,4BAAA,EAAA,OAAA,EAAA,GAAA;;AACA,qBAAA,uBAAA,CAAA,OAAA;;AACA,oBAAMV,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAIA,GAAG,KAAP,IAAA,EAAkB;AAChB;AACD;;AACD,oBAAMsC,MAAM,GAAGC,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,MAAAA,KAA1B,IAAeA,CAAf;AACA,oBAAIO,iBAAiB,GAAG3D,UAAU,CAAC,YAAA;AAAA,yBAAM,OAAI,CAAJ,WAAA,CAAN,OAAM,CAAN;AAAD,iBAAA,EAAkC,KAAA,OAAA,CAAA,kBAAA,GAApE,MAAkC,CAAlC;AACA,qBAAA,mBAAA,CAAA,OAAA,IAAA,iBAAA;AACA;AACD;;;kDAEmBgC,O,EAASK,M,EAAQ;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACnC,qBAAA,MAAA,CAAA,8BAAA,EAAA,OAAA;;AACA,qBAAA,uBAAA,CAAA,OAAA;;AACA,oBAAMxB,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAIA,GAAG,KAAP,IAAA,EAAkB;AAChB;AACD;;AACD,oBAAIwB,MAAM,CAANA,OAAAA,KAAJ,IAAA,EAA6B;AAC3B,sBAAIsB,iBAAiB,GAAG3D,UAAU,CAAC,YAAA;AAAA,2BAAM,OAAI,CAAJ,WAAA,CAAN,OAAM,CAAN;AAAD,mBAAA,EAAkC,KAAA,mBAAA,CAAyBqC,MAAM,CAAnG,GAAoE,CAAlC,CAAlC;AACA,uBAAA,mBAAA,CAAA,OAAA,IAAA,iBAAA;AACD;;AACD;AACD;;;yCAEUxB,G,EAAK+C,a,EAAe;AAAA,oBAAA,OAAA,GAAA,IAAA;;AAC7B,qBAAA,MAAA,CAAA,gBAAA,EAA8B/C,GAAG,CAAjC,OAAA;;AACA,oBAAMmB,OAAO,GAAGnB,GAAG,CAAnB,OAAA;;AAEA,oBAAI,EAAEmB,OAAO,IAAI,KAAjB,KAAI,CAAJ,EAA8B;AAC5B,uBAAA,KAAA,CAAA,OAAA,IAAA,GAAA;AACD;;AAED,oBAAI,CAAC,KAAL,WAAK,EAAL,EAAyB;AACvB;AACAnB,kBAAAA,GAAG,CAAHA,OAAAA;;AACA;AACD;;AAEDA,gBAAAA,GAAG,CAAHA,eAAAA,CAAAA,aAAAA;;AAEA,oBAAMM,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CADE,SAAA;AAEVzC,kBAAAA,MAAM,EAAE;AACN2C,oBAAAA,OAAO,EAAEA;AADH;AAFE,iBAAZ,CAhB6B,CAuB7B;AACA;AACA;AACA;;AACA,oBAAI,CAAA,GAAA,MAAA,CAAA,UAAA,EAAA,OAAA,EAAoB,KAAA,OAAA,CAAxB,oBAAI,CAAJ,EAA4D;AAC1D;AACA,sBAAI,KAAJ,oBAAA,EAA+B;AAC7B,yBAAA,gBAAA,CAAA,OAAA,IAAA,IAAA;AADF,mBAAA,MAEO;AACL,yBAAA,sBAAA;;AACA,yBAAA,UAAA,CAAA,GAAA;;AACA,yBAAA,qBAAA;AACD;AARH,iBAAA,MASO;AACL,sBAAM6B,OAAO,GAAGhD,GAAG,CAAnB,YAAgBA,EAAhB;;AAEA,sBAAIgD,OAAO,KAAX,IAAA,EAAsB;AACpB1C,oBAAAA,GAAG,CAAHA,MAAAA,CAAAA,OAAAA,GAAAA,IAAAA;;AACA,wBAAM2C,GAAG,GAAG,KAAA,WAAA,CAAZ,OAAY,CAAZ;;AACA,wBAAMC,GAAG,GAAG,KAAA,WAAA,CAAZ,OAAY,CAAZ;;AACA,wBAAID,GAAG,IAAP,GAAA,EAAgB;AACd,0BAAA,GAAA,EAAS;AACP3C,wBAAAA,GAAG,CAAHA,MAAAA,CAAAA,GAAAA,GAAAA,GAAAA;AACD;;AACD,0BAAA,GAAA,EAAS;AACPA,wBAAAA,GAAG,CAAHA,MAAAA,CAAAA,GAAAA,GAAAA,GAAAA;AACD;AANH,qBAAA,MAOO;AACL,0BAAM6C,MAAM,GAAG,KAAA,cAAA,CAAf,OAAe,CAAf;;AACA,0BAAA,MAAA,EAAY;AACV7C,wBAAAA,GAAG,CAAHA,MAAAA,CAAAA,MAAAA,GAAAA,MAAAA;AACD;AACF;;AACD,wBAAM8C,KAAK,GAAG,KAAA,aAAA,CAAd,OAAc,CAAd;;AACA,wBAAA,KAAA,EAAW;AACT9C,sBAAAA,GAAG,CAAHA,MAAAA,CAAAA,KAAAA,GAAAA,KAAAA;AACD;AACF;;AAED,uBAAA,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,oBAAA,OAAI,CAAJ,kBAAA,CAAA,OAAA,EAAA,OAAA,EAGE,OAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,OAAI,CAAJ,WAAA,CAAlC,SAAA,EAA8DG,UAAU,CAH1E,MAGE,CAHF;;AAKA,wBAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,sBAAAA,UAAU,CAAVA,IAAAA;AACD;AARH,mBAAA,EASG,UAAA,SAAA,EAAa;AACd,oBAAA,OAAI,CAAJ,eAAA,CAAA,OAAA,EAA8BE,SAAS,CAAvC,KAAA;;AACA,wBAAIA,SAAS,CAAb,IAAA,EAAoB;AAClBA,sBAAAA,SAAS,CAATA,IAAAA;AACD;AAbH,mBAAA;AAeD;AACF;;;2CAEYX,G,EAAK;AAChB,uBAAO,KAAA,KAAA,CAAWA,GAAG,CAArB,OAAO,CAAP;AACA,uBAAO,KAAA,WAAA,CAAiBA,GAAG,CAA3B,OAAO,CAAP;AACA,uBAAO,KAAA,QAAA,CAAcA,GAAG,CAAxB,OAAO,CAAP;AACA,uBAAO,KAAA,QAAA,CAAcA,GAAG,CAAxB,OAAO,CAAP;;AACA,oBAAI,KAAJ,WAAI,EAAJ,EAAwB;AACtB;AACA,uBAAA,WAAA,CAAiB;AACfiB,oBAAAA,MAAM,EAAE,KAAA,WAAA,CADO,WAAA;AAEfzC,oBAAAA,MAAM,EAAE;AACN2C,sBAAAA,OAAO,EAAEnB,GAAG,CAACmB;AADP;AAFO,mBAAjB;AAMD;AACF;;;kDAEmBkC,G,EAAK;AACvB;AACA,uBAAOd,IAAI,CAAJA,GAAAA,CAASc,GAAG,GAAZd,IAAAA,EAAP,UAAOA,CAAP;AACD;;;qCAEMpB,O,EAAS;AACd,uBAAO,KAAA,OAAA,CAAP,OAAO,CAAP;AACD;;;sCAEOA,O,EAAS;AACf,oBAAMnB,GAAG,GAAG,KAAA,KAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR,yBAAA,IAAA;AACD;;AACD,uBAAA,GAAA;AACD;;;2CAEYmB,O,EAAS;AACpB,uBAAO,KAAA,WAAA,CAAA,OAAA,MAAP,SAAA;AACD;;;+CAEgBK,M,EAAQ8B,S,EAAW;AAAA,oBAAA,OAAA,GAAA,IAAA;;AAClC,oBAAMC,eAAe,GAAG,KAAxB,aAAA;AACA,qBAAA,aAAA,GAAA,KAAA;;AACA,qBAAA,WAAA;;AACA,qBAAA,gBAAA,GAAA,KAAA;;AAEA,oBAAI,KAAJ,WAAI,EAAJ,EAAwB;AACtB;AACD;;AAED,oBAAI,KAAA,aAAA,KAAJ,IAAA,EAAiC;AAC/B,uBAAA,QAAA,GAAiB,IAAD,IAAC,GAAD,OAAC,KAAwB,KAAA,aAAA,CAAzC,OAAyC,EAAzC;AACA,uBAAA,aAAA,GAAA,IAAA;AACD;;AAED,qBAAA,SAAA,GAAiB/B,MAAM,CAAvB,MAAA;;AACA,qBAAA,UAAA,CAAA,WAAA;;AAEA,oBAAI,KAAJ,eAAA,EAA0B;AACxB1B,kBAAAA,YAAY,CAAC,KAAbA,eAAY,CAAZA;AACD;;AAED,oBAAI0B,MAAM,CAAV,OAAA,EAAoB;AAClB,uBAAA,eAAA,GAAuBrC,UAAU,CAAC,YAAA;AAAA,2BAAM,OAAI,CAAV,QAAM,EAAN;AAAD,mBAAA,EAAwB,KAAA,mBAAA,CAAyBqC,MAAM,CAAxF,GAAyD,CAAxB,CAAjC;AACD;;AAED,qBAAA,aAAA;AACA,qBAAA,sBAAA;;AACA,qBAAK,IAAL,OAAA,IAAsB,KAAtB,KAAA,EAAkC;AAChC,sBAAI,KAAA,KAAA,CAAA,cAAA,CAAJ,OAAI,CAAJ,EAAwC;AACtC,wBAAMxB,GAAG,GAAG,KAAA,KAAA,CAAZ,OAAY,CAAZ;;AACA,wBAAIA,GAAG,CAAP,kBAAIA,EAAJ,EAA8B;AAC5B,2BAAA,UAAA,CAAA,GAAA,EAAA,eAAA;AACD;AACF;AACF;;AACD,qBAAA,qBAAA;AACA,qBAAA,YAAA;;AAEA,qBAAA,UAAA;;AAEA,oBAAMwD,GAAG,GAAG;AACVZ,kBAAAA,MAAM,EAAEpB,MAAM,CADJ,MAAA;AAEViC,kBAAAA,SAAS,EAAE,KAFD,cAAA;AAGVC,kBAAAA,OAAO,EAAE,KAAKC;AAHJ,iBAAZ;;AAKA,oBAAInC,MAAM,CAAV,IAAA,EAAiB;AACfgC,kBAAAA,GAAG,CAAHA,IAAAA,GAAWhC,MAAM,CAAjBgC,IAAAA;AACD;;AAED,qBAAA,IAAA,CAAA,SAAA,EAAA,GAAA;;AAEA,oBAAIhC,MAAM,CAAV,IAAA,EAAiB;AACf,uBAAA,kBAAA,CAAwBA,MAAM,CAA9B,IAAA;AACD;AACF;;;iDAEkBjB,I,EAAM;AACvB,qBAAK,IAAL,OAAA,IAAA,IAAA,EAA4B;AAC1B,sBAAIA,IAAI,CAAJA,cAAAA,CAAJ,OAAIA,CAAJ,EAAkC;AAChC,wBAAMP,GAAG,GAAGO,IAAI,CAAhB,OAAgB,CAAhB;AACA,wBAAMwC,aAAa,GAAG,KAAA,WAAA,CAAA,OAAA,MAAtB,SAAA;AACA,wBAAIa,MAAM,GAAG;AAACzC,sBAAAA,OAAO,EAAR,OAAA;AAAmB4B,sBAAAA,aAAa,EAAEA;AAAlC,qBAAb;AACAa,oBAAAA,MAAM,GAAG,KAAA,uBAAA,CAAA,MAAA,EAATA,GAAS,CAATA;AACA,yBAAA,IAAA,CAAA,WAAA,EAAA,MAAA;AACD;AACF;;AACD,qBAAK,IAAL,SAAA,IAAA,IAAA,EAA4B;AAC1B,sBAAIrD,IAAI,CAAJA,cAAAA,CAAJ,SAAIA,CAAJ,EAAkC;AAChC,wBAAMP,IAAG,GAAGO,IAAI,CAAhB,SAAgB,CAAhB;;AACA,wBAAIP,IAAG,CAAP,SAAA,EAAmB;AACjB,0BAAI6D,IAAI,GAAG7D,IAAG,CAAd,YAAA;;AACA,0BAAI6D,IAAI,IAAIA,IAAI,CAAJA,MAAAA,GAAZ,CAAA,EAA6B;AAE3B;AACA;AACA,4BAAIA,IAAI,CAAJA,MAAAA,GAAAA,CAAAA,KAAoB,CAACA,IAAI,CAAJA,CAAI,CAAJA,CAAD,MAAA,IAAmBA,IAAI,CAAJA,CAAI,CAAJA,CAAAA,MAAAA,GAAiBA,IAAI,CAAJA,CAAI,CAAJA,CAA5D,MAAIA,CAAJ,EAA6E;AAC3EA,0BAAAA,IAAI,GAAGA,IAAI,CAAXA,OAAOA,EAAPA;AACD;;AAED,6BAAK,IAAL,CAAA,IAAA,IAAA,EAAoB;AAClB,8BAAIA,IAAI,CAAJA,cAAAA,CAAJ,CAAIA,CAAJ,EAA4B;AAC1B,iCAAA,kBAAA,CAAA,SAAA,EAAiCA,IAAI,CAArC,CAAqC,CAArC;AACD;AACF;AACF;AACF;;AACD,yBAAA,WAAA,CAAA,SAAA,IAA4B;AAC1B,6BAAO7D,IAAG,CADgB,GAAA;AAE1B,6BAAOA,IAAG,CAFgB,GAAA;AAG1B,gCAAUA,IAAG,CAHa,MAAA;AAI1B,+BAASA,IAAG,CAJc,KAAA;AAK1B,qCAAeA,IAAG,CAAC8D;AALO,qBAA5B;AAOD;AACF;AACF;;;0CAEW;AACV,oBAAI,KAAA,YAAA,KAAJ,IAAA,EAAgC;AAC9BhE,kBAAAA,YAAY,CAAC,KAAbA,YAAY,CAAZA;AACA,uBAAA,YAAA,GAAA,IAAA;AACD;;AACD,oBAAI,KAAA,YAAA,KAAJ,IAAA,EAAgC;AAC9BA,kBAAAA,YAAY,CAAC,KAAbA,YAAY,CAAZA;AACA,uBAAA,YAAA,GAAA,IAAA;AACD;AACF;;;2CAEY;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACX,oBAAI,KAAA,OAAA,CAAA,IAAA,KAAA,IAAA,IAA8B,KAAA,OAAA,CAAA,YAAA,IAAlC,CAAA,EAAkE;AAChE;AACD;;AACD,oBAAI,CAAC,KAAL,WAAK,EAAL,EAAyB;AACvB;AACD;;AAED,qBAAA,YAAA,GAAoBX,UAAU,CAAC,YAAM;AACnC,sBAAI,CAAC,OAAI,CAAT,WAAK,EAAL,EAAyB;AACvB,oBAAA,OAAI,CAAJ,SAAA;;AACA;AACD;;AACD,kBAAA,OAAI,CAAJ,IAAA;;AACA,kBAAA,OAAI,CAAJ,YAAA,GAAoBA,UAAU,CAAC,YAAM;AACnC,oBAAA,OAAI,CAAJ,WAAA,CAAA,SAAA,EAAA,IAAA;AAD4B,mBAAA,EAE3B,OAAI,CAAJ,OAAA,CAFH,eAA8B,CAA9B;AAN4B,iBAAA,EAS3B,KAAA,OAAA,CATH,YAA8B,CAA9B;AAUD;;;6CAEc;AACb,qBAAA,SAAA;;AACA,qBAAA,UAAA;AACD;;;8CAEegC,O,EAASlC,K,EAAO;AAC9B,oBAAMe,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR;AACD;;AACD,oBAAI,CAACA,GAAG,CAAR,cAAKA,EAAL,EAA2B;AACzB;AACD;;AACD,oBAAIf,KAAK,CAALA,IAAAA,KAAAA,CAAAA,IAAoBA,KAAK,CAALA,OAAAA,KAAxB,aAAA,EAAyD;AAAE;AACzD,uBAAA,WAAA,CAAA,SAAA,EAAA,IAAA;;AACA;AACD;;AACDe,gBAAAA,GAAG,CAAHA,kBAAAA,CAAAA,KAAAA;AACD;;;sDAEuBwD,G,EAAKhC,M,EAAQ;AACnC,oBAAIuC,SAAS,GAAb,KAAA;;AACA,oBAAI,eAAJ,MAAA,EAA2B;AACzBA,kBAAAA,SAAS,GAAGvC,MAAM,CAAlBuC,SAAAA;AACD;;AACDP,gBAAAA,GAAG,CAAHA,SAAAA,GAAAA,SAAAA;AAEA,oBAAIQ,UAAU,GAAd,KAAA;;AACA,oBAAI,gBAAJ,MAAA,EAA4B;AAC1BA,kBAAAA,UAAU,GAAGxC,MAAM,CAAnBwC,UAAAA;AACD;;AACD,oBAAIZ,KAAK,GAAT,EAAA;;AACA,oBAAI,WAAJ,MAAA,EAAuB;AACrBA,kBAAAA,KAAK,GAAG5B,MAAM,CAAd4B,KAAAA;AACD;;AACD,oBAAID,MAAM,GAAV,CAAA;;AACA,oBAAI,YAAJ,MAAA,EAAwB;AACtBA,kBAAAA,MAAM,GAAG3B,MAAM,CAAf2B,MAAAA;AACD;;AACD,oBAAA,UAAA,EAAgB;AACdK,kBAAAA,GAAG,CAAHA,cAAAA,GAAqB;AACnB,8BADmB,MAAA;AAEnB,6BAASJ;AAFU,mBAArBI;AAID;;AAAA;;AACD,oBAAIhC,MAAM,CAAV,IAAA,EAAiB;AACfgC,kBAAAA,GAAG,CAAHA,IAAAA,GAAWhC,MAAM,CAAjBgC,IAAAA;AACD;;AACD,uBAAA,GAAA;AACD;;;iDAEkBrC,O,EAASmC,S,EAAW9B,M,EAAQ;AAAA,oBAAA,OAAA,GAAA,IAAA;;AAC7C,oBAAMxB,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR;AACD;;AACD,oBAAI,CAACA,GAAG,CAAR,cAAKA,EAAL,EAA2B;AACzB;AACD;;AACDA,gBAAAA,GAAG,CAAHA,oBAAAA,CAAAA,MAAAA;;AAEA,oBAAI6D,IAAI,GAAGrC,MAAM,CAAjB,YAAA;;AACA,oBAAIqC,IAAI,IAAIA,IAAI,CAAJA,MAAAA,GAAZ,CAAA,EAA6B;AAC3B,sBAAIA,IAAI,CAAJA,MAAAA,IAAAA,CAAAA,IAAoB,CAACA,IAAI,CAAJA,CAAI,CAAJA,CAArBA,MAAAA,IAAuC,CAACA,IAAI,CAAJA,CAAI,CAAJA,CAA5C,MAAA,EAA4D;AAC1D;AACAA,oBAAAA,IAAI,GAAGA,IAAI,CAAXA,OAAOA,EAAPA;AACD;;AACD,uBAAK,IAAL,CAAA,IAAA,IAAA,EAAoB;AAClB,wBAAIA,IAAI,CAAJA,cAAAA,CAAJ,CAAIA,CAAJ,EAA4B;AAC1B,2BAAA,kBAAA,CAAA,OAAA,EAAiCA,IAAI,CAArC,CAAqC,CAArC;AACD;AACF;AACF;;AAED,oBAAIrC,MAAM,CAANA,WAAAA,KAAuB,CAAA,SAAA,IAAc,CAACA,MAAM,CAAhD,SAAIA,CAAJ,EAA6D;AAC3D,uBAAA,QAAA,CAAA,OAAA,IAAyBA,MAAM,CAANA,GAAAA,IAAzB,CAAA;AACA,uBAAA,QAAA,CAAA,OAAA,IAAyBA,MAAM,CAANA,GAAAA,IAAzB,CAAA;AACA,uBAAA,WAAA,CAAA,OAAA,IAA4BA,MAAM,CAANA,MAAAA,IAA5B,CAAA;AACD;;AAED,qBAAA,UAAA,CAAA,OAAA,IAA2BA,MAAM,CAANA,KAAAA,IAA3B,EAAA;;AAEA,oBAAIA,MAAM,CAAV,WAAA,EAAwB;AACtBxB,kBAAAA,GAAG,CAAHA,YAAAA,GAAAA,IAAAA;AACD;;AAED,oBAAIwB,MAAM,CAANA,OAAAA,KAAJ,IAAA,EAA6B;AAC3B,sBAAIsB,iBAAiB,GAAG3D,UAAU,CAAC,YAAA;AAAA,2BAAM,OAAI,CAAJ,WAAA,CAAN,OAAM,CAAN;AAAD,mBAAA,EAAkC,KAAA,mBAAA,CAAyBqC,MAAM,CAAnG,GAAoE,CAAlC,CAAlC;AACA,uBAAA,mBAAA,CAAA,OAAA,IAAA,iBAAA;AACD;AACF;;;2CAEYO,K,EAAOC,I,EAAM;AACxB,oBAAM9B,EAAE,GAAG6B,KAAK,CAAhB,EAAA;AACA,oBAAMP,MAAM,GAAGO,KAAK,CAApB,MAAA;;AAEA,oBAAI,EAAE7B,EAAE,IAAI,KAAZ,UAAI,CAAJ,EAA8B;AAC5B8B,kBAAAA,IAAI;AACJ;AACD;;AACD,oBAAMnC,SAAS,GAAG,KAAA,UAAA,CAAlB,EAAkB,CAAlB;AACAC,gBAAAA,YAAY,CAAC,KAAA,UAAA,CAAA,EAAA,EAAbA,OAAY,CAAZA;AACA,uBAAO,KAAA,UAAA,CAAP,EAAO,CAAP;;AAEA,oBAAI,CAAC,CAAA,GAAA,MAAA,CAAA,WAAA,EAAL,KAAK,CAAL,EAAyB;AACvB,sBAAMpB,QAAQ,GAAGmB,SAAS,CAA1B,QAAA;;AACA,sBAAI,CAAJ,QAAA,EAAe;AACb;AACD;;AACDnB,kBAAAA,QAAQ,CAAC;AAAC8C,oBAAAA,MAAM,EAAP,MAAA;AAASQ,oBAAAA,IAAI,EAAJA;AAAT,mBAAD,CAARtD;AALF,iBAAA,MAMO;AACL,sBAAMqB,OAAO,GAAGF,SAAS,CAAzB,OAAA;;AACA,sBAAI,CAAJ,OAAA,EAAc;AACZmC,oBAAAA,IAAI;AACJ;AACD;;AACD,sBAAM/C,KAAK,GAAG8C,KAAK,CAAnB,KAAA;AACAhC,kBAAAA,OAAO,CAAC;AAACd,oBAAAA,KAAK,EAAN,KAAA;AAAQ+C,oBAAAA,IAAI,EAAJA;AAAR,mBAAD,CAAPjC;AACD;AACF;;;0CAEWoB,O,EAAS8C,I,EAAM;AACzB,oBAAMT,GAAG,GAAG;AAAC,0BAAQS,IAAI,CAACC;AAAd,iBAAZ;;AACA,oBAAMlE,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR,sBAAI,KAAA,YAAA,CAAJ,OAAI,CAAJ,EAAgC;AAC9BwD,oBAAAA,GAAG,CAAHA,OAAAA,GAAAA,OAAAA;AACA,yBAAA,IAAA,CAAA,MAAA,EAAA,GAAA;AACD;;AACD;AACD;;AACDxD,gBAAAA,GAAG,CAAHA,IAAAA,CAAAA,MAAAA,EAAAA,GAAAA;AACD;;;2CAEYmB,O,EAASgD,K,EAAO;AAC3B,oBAAMX,GAAG,GAAG;AAAC,0BAAQW,KAAK,CAACD;AAAf,iBAAZ;;AACA,oBAAMlE,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR,sBAAI,KAAA,YAAA,CAAJ,OAAI,CAAJ,EAAgC;AAC9BwD,oBAAAA,GAAG,CAAHA,OAAAA,GAAAA,OAAAA;AACA,yBAAA,IAAA,CAAA,OAAA,EAAA,GAAA;AACD;;AACD;AACD;;AACDxD,gBAAAA,GAAG,CAAHA,IAAAA,CAAAA,OAAAA,EAAAA,GAAAA;AACD;;;2CAEYmB,O,EAASiD,K,EAAO;AAC3B,oBAAMZ,GAAG,GAAT,EAAA;;AACA,oBAAMxD,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAI,CAAJ,GAAA,EAAU;AACR,sBAAI,KAAA,YAAA,CAAJ,OAAI,CAAJ,EAAgC;AAC9B,2BAAO,KAAA,WAAA,CAAP,OAAO,CAAP;AACAwD,oBAAAA,GAAG,CAAHA,OAAAA,GAAAA,OAAAA;AACA,yBAAA,IAAA,CAAA,aAAA,EAAA,GAAA;AACD;;AACD;AACD;;AACDxD,gBAAAA,GAAG,CAAHA,WAAAA;;AACA,oBAAIoE,KAAK,CAALA,WAAAA,KAAJ,IAAA,EAAgC;AAC9BpE,kBAAAA,GAAG,CAAHA,SAAAA;AACD;AACF;;;yCAEUmB,O,EAASnB,G,EAAK;AACvB,qBAAA,WAAA,CAAA,OAAA,IAA4B;AAC1B,yBAAOA,GAAG,CADgB,GAAA;AAE1B,yBAAOA,GAAG,CAFgB,GAAA;AAG1B,4BAAUA,GAAG,CAHa,MAAA;AAI1B,2BAASA,GAAG,CAJc,KAAA;AAK1B,iCAAeA,GAAG,CAAC8D;AALO,iBAA5B;AAOA,oBAAIN,GAAG,GAAG;AAAC,6BAAD,OAAA;AAAqBT,kBAAAA,aAAa,EAAE;AAApC,iBAAV;AACAS,gBAAAA,GAAG,GAAG,KAAA,uBAAA,CAAA,GAAA,EAANA,GAAM,CAANA;AACA,qBAAA,IAAA,CAAA,WAAA,EAAA,GAAA;AACD;;;iDAEkBrC,O,EAASkD,G,EAAK;AAC/B,oBAAMrE,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,oBAAMwD,GAAG,GAAG;AACV,0BAAQa,GAAG,CADD,IAAA;AAEV,yBAAOA,GAAG,CAFA,GAAA;AAGV,yBAAOA,GAAG,CAHA,GAAA;AAIV,4BAAUA,GAAG,CAAClB;AAJJ,iBAAZ;;AAMA,oBAAIkB,GAAG,CAAP,IAAA,EAAc;AACZb,kBAAAA,GAAG,CAAHA,IAAAA,GAAWa,GAAG,CAAdb,IAAAA;AACD;;AACD,oBAAI,CAAJ,GAAA,EAAU;AACR,sBAAI,KAAA,YAAA,CAAJ,OAAI,CAAJ,EAAgC;AAC9B,wBAAIa,GAAG,CAAHA,GAAAA,KAAJ,SAAA,EAA2B;AACzB,2BAAA,WAAA,CAAA,OAAA,EAAA,GAAA,GAAgCA,GAAG,CAAnC,GAAA;AACD;;AACD,wBAAIA,GAAG,CAAHA,GAAAA,KAAJ,SAAA,EAA2B;AACzB,2BAAA,WAAA,CAAA,OAAA,EAAA,GAAA,GAAgCA,GAAG,CAAnC,GAAA;AACD;;AACD,wBAAIA,GAAG,CAAHA,MAAAA,KAAJ,SAAA,EAA8B;AAC5B,2BAAA,WAAA,CAAA,OAAA,EAAA,MAAA,GAAmCA,GAAG,CAAtC,MAAA;AACD;;AACDb,oBAAAA,GAAG,CAAHA,OAAAA,GAAAA,OAAAA;AACA,yBAAA,IAAA,CAAA,SAAA,EAAA,GAAA;AACD;;AACD;AACD;;AACD,oBAAIa,GAAG,CAAHA,GAAAA,KAAJ,SAAA,EAA2B;AACzB,uBAAA,QAAA,CAAA,OAAA,IAAyBA,GAAG,CAA5B,GAAA;AACD;;AACD,oBAAIA,GAAG,CAAHA,GAAAA,KAAJ,SAAA,EAA2B;AACzB,uBAAA,QAAA,CAAA,OAAA,IAAyBA,GAAG,CAA5B,GAAA;AACD;;AACD,oBAAIA,GAAG,CAAHA,MAAAA,KAAJ,SAAA,EAA8B;AAC5B,uBAAA,WAAA,CAAA,OAAA,IAA4BA,GAAG,CAA/B,MAAA;AACD;;AACDrE,gBAAAA,GAAG,CAAHA,IAAAA,CAAAA,SAAAA,EAAAA,GAAAA;AACD;;;6CAEcsE,O,EAAS;AACtB,qBAAA,IAAA,CAAA,SAAA,EAAqBA,OAAO,CAA5B,IAAA;AACD;;;0CAEWhG,I,EAAM0D,I,EAAM;AACtB,oBAAMuC,IAAI,GAAG,KAAA,QAAA,CAAA,UAAA,CAAb,IAAa,CAAb;;AACA,oBAAIC,IAAI,GAAR,CAAA;;AACA,oBAAI,UAAJ,IAAA,EAAoB;AAClBA,kBAAAA,IAAI,GAAGD,IAAI,CAAXC,MAAW,CAAXA;AACD;;AACD,oBAAMrD,OAAO,GAAGoD,IAAI,CAApB,OAAA;;AAEA,oBAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,WAAA,EAAyC;AACvC,sBAAMH,GAAG,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,WAAA,EAAyDE,IAAI,CAAzE,IAAY,CAAZ;;AACA,uBAAA,kBAAA,CAAA,OAAA,EAAA,GAAA;AAFF,iBAAA,MAGO,IAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,OAAA,EAAqC;AAC1C,sBAAMF,OAAO,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,OAAA,EAAqDC,IAAI,CAAzE,IAAgB,CAAhB;;AACA,uBAAA,cAAA,CAAA,OAAA;AAFK,iBAAA,MAGA,IAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,IAAA,EAAkC;AACvC,sBAAMP,IAAI,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,IAAA,EAAkDM,IAAI,CAAnE,IAAa,CAAb;;AACA,uBAAA,WAAA,CAAA,OAAA,EAAA,IAAA;AAFK,iBAAA,MAGA,IAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,KAAA,EAAmC;AACxC,sBAAML,KAAK,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,KAAA,EAAmDI,IAAI,CAArE,IAAc,CAAd;;AACA,uBAAA,YAAA,CAAA,OAAA,EAAA,KAAA;AAFK,iBAAA,MAGA,IAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,KAAA,EAAmC;AACxC,sBAAMJ,KAAK,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,KAAA,EAAmDG,IAAI,CAArE,IAAc,CAAd;;AACA,uBAAA,YAAA,CAAA,OAAA,EAAA,KAAA;AAFK,iBAAA,MAGA,IAAIC,IAAI,KAAK,KAAA,SAAA,CAAb,GAAA,EAAiC;AACtC,sBAAMxE,GAAG,GAAG,KAAA,QAAA,CAAA,cAAA,CAA6B,KAAA,SAAA,CAA7B,GAAA,EAAiDuE,IAAI,CAAjE,IAAY,CAAZ;;AACA,uBAAA,UAAA,CAAA,OAAA,EAAA,GAAA;AACD;;AACDvC,gBAAAA,IAAI;AACL;;;uCAEQ;AACP,oBAAMyC,QAAQ,GAAG,KAAA,SAAA,CAAA,KAAA,CAAjB,CAAiB,CAAjB;;AACA,qBAAA,SAAA,GAAA,EAAA;;AACA,qBAAA,cAAA,CAAA,QAAA;AACD;;;sCAEO;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACN,oBAAMnE,GAAG,GAAG;AACVW,kBAAAA,MAAM,EAAE,KAAA,WAAA,CAAiByD;AADf,iBAAZ;;AAGA,qBAAA,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,kBAAA,OAAI,CAAJ,aAAA,CAAmB,OAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,OAAI,CAAJ,WAAA,CAAlC,IAAA,EAAyDjE,UAAU,CAAtF,MAAmB,CAAnB;;AACA,sBAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,oBAAAA,UAAU,CAAVA,IAAAA;AACD;AAJH,iBAAA,EAKG,UAAA,SAAA,EAAa;AACd,kBAAA,OAAI,CAAJ,MAAA,CAAA,YAAA,EAA0BE,SAAS,CAAnC,KAAA;;AACA,sBAAIA,SAAS,CAAb,IAAA,EAAoB;AAClBA,oBAAAA,SAAS,CAATA,IAAAA;AACD;AATH,iBAAA;AAWD;;;4CAEaa,M,EAAQ;AACpB,oBAAI,CAAC,KAAL,WAAK,EAAL,EAAyB;AACvB;AACD;;AACD,qBAAA,SAAA;;AACA,qBAAA,UAAA;AACD;;;0CAEWL,O,EAAS;AACnB,oBAAMwD,OAAO,GAAG,KAAA,QAAA,CAAhB,OAAgB,CAAhB;;AACA,oBAAA,OAAA,EAAa;AACX,yBAAA,OAAA;AACD;;AACD,uBAAA,CAAA;AACD;;;6CAEcxD,O,EAAS;AACtB,oBAAMyD,UAAU,GAAG,KAAA,WAAA,CAAnB,OAAmB,CAAnB;;AACA,oBAAA,UAAA,EAAgB;AACd,yBAAA,UAAA;AACD;;AACD,uBAAA,CAAA;AACD;;;0CAEWzD,O,EAAS;AACnB,oBAAM0D,OAAO,GAAG,KAAA,QAAA,CAAhB,OAAgB,CAAhB;;AACA,oBAAA,OAAA,EAAa;AACX,yBAAA,OAAA;AACD;;AACD,uBAAA,CAAA;AACD;;;4CAEa1D,O,EAAS;AACrB,oBAAM2D,SAAS,GAAG,KAAA,UAAA,CAAlB,OAAkB,CAAlB;;AACA,oBAAA,SAAA,EAAe;AACb,yBAAA,SAAA;AACD;;AACD,uBAAA,EAAA;AACD;;;iDAEkBR,O,EAASS,I,EAAM;AAChC,oBAAMC,SAAS,GAAG;AAChBV,kBAAAA,OAAO,EADS,OAAA;AAEhBS,kBAAAA,IAAI,EAAEA,IAAI,IAAI;AAFE,iBAAlB;AAKA,uBAAA,SAAA;AACD;;;4CAEa7E,E,EAAIxB,Q,EAAUqB,O,EAAS;AAAA,oBAAA,OAAA,GAAA,IAAA;;AACnC,qBAAA,UAAA,CAAA,EAAA,IAAsB;AACpBrB,kBAAAA,QAAQ,EADY,QAAA;AAEpBqB,kBAAAA,OAAO,EAFa,OAAA;AAGpB/C,kBAAAA,OAAO,EAAE;AAHW,iBAAtB;AAKA,qBAAA,UAAA,CAAA,EAAA,EAAA,OAAA,GAA8BmC,UAAU,CAAC,YAAM;AAC7C,yBAAO,OAAI,CAAJ,UAAA,CAAP,EAAO,CAAP;;AACA,sBAAI,CAAA,GAAA,MAAA,CAAA,UAAA,EAAJ,OAAI,CAAJ,EAAyB;AACvBY,oBAAAA,OAAO,CAAC;AAACd,sBAAAA,KAAK,EAAE,OAAI,CAAJ,kBAAA,CAAA,aAAA;AAAR,qBAAD,CAAPc;AACD;AAJqC,iBAAA,EAKrC,KAAA,OAAA,CALH,OAAwC,CAAxC;AAMD;;;0CAEWuE,O,EAAS;AACnB,oBAAIpE,EAAE,GAAG,KAAT,cAAS,EAAT;;AACAoE,gBAAAA,OAAO,CAAPA,EAAAA,GAAAA,EAAAA;;AACA,oBAAI,KAAA,WAAA,KAAJ,IAAA,EAA+B;AAC7B,uBAAA,SAAA,CAAA,IAAA,CAAA,OAAA;AADF,iBAAA,MAEO;AACL,uBAAA,cAAA,CAAoB,CAApB,OAAoB,CAApB;AACD;;AACD,uBAAA,EAAA;AACD;;;4CAEa;AACZ,uBAAO,KAAP,YAAO,EAAP;AACD;;;wCAES;AACR,qBAAA,QAAA;AACD;;;2CAEY;AACX,qBAAA,WAAA,CAAA,QAAA,EAAA,KAAA;AACD;;;qCAEM;AACL,uBAAO,KAAP,KAAO,EAAP;AACD;;;8CAEe;AACd;AACA;AACA,qBAAA,WAAA,GAAA,IAAA;AACD;;;6CAEc;AACb,qBAAA,WAAA,GAAA,KAAA;;AACA,qBAAA,MAAA;AACD;;;uDAEwB;AACvB;AACA;AACA,qBAAA,oBAAA,GAAA,IAAA;AACD;;;sDAEuB;AAAA,oBAAA,OAAA,GAAA,IAAA,CAAA,CACtB;AACA;;;AACA,qBAAA,oBAAA,GAAA,KAAA;AACA,oBAAMW,YAAY,GAAG,KAArB,gBAAA;AACA,qBAAA,gBAAA,GAAA,EAAA;AAEA,oBAAMpC,QAAQ,GAAd,EAAA;;AAEA,qBAAK,IAAL,OAAA,IAAA,YAAA,EAAoC;AAClC,sBAAIoC,YAAY,CAAZA,cAAAA,CAAJ,OAAIA,CAAJ,EAA0C;AACxC,wBAAMjF,GAAG,GAAG,KAAA,OAAA,CAAZ,OAAY,CAAZ;;AACA,wBAAI,CAAJ,GAAA,EAAU;AACR;AACD;;AACD6C,oBAAAA,QAAQ,CAARA,IAAAA,CAAAA,OAAAA;AACD;AACF;;AAED,oBAAIA,QAAQ,CAARA,MAAAA,KAAJ,CAAA,EAA2B;AACzB,uBAAA,MAAA,CAAA,oDAAA;;AACA;AACD;;AAED,oBAAMvE,IAAI,GAAG;AACXsE,kBAAAA,MAAM,EAAE,KADG,SAAA;AAEXC,kBAAAA,QAAQ,EAAEA;AAFC,iBAAb;AAKA,oBAAMX,QAAQ,GAAG,KAAjB,SAAA;;AACA,oBAAMC,KAAK,GAAG,KAAd,SAAc,EAAd;;AAEA,oBAAMC,EAAE,GAAG,SAALA,EAAK,CAAA,IAAA,EAAU;AACnB,sBAAID,KAAK,IAAI,OAAI,CAAjB,KAAA,EAAyB;AACvB,2BAAO,OAAI,CAAJ,KAAA,CAAP,KAAO,CAAP;AACD;;AACD,sBAAI,OAAI,CAAJ,SAAA,KAAJ,QAAA,EAAiC;AAC/B;AACD;;AACD,sBAAIE,IAAI,CAAJA,KAAAA,IAAcA,IAAI,CAAJA,MAAAA,KAAlB,GAAA,EAAuC;AACrC,oBAAA,OAAI,CAAJ,MAAA,CAAA,8BAAA;;AACA,yBAAK,IAAL,CAAA,IAAA,QAAA,EAA0B;AACxB,0BAAIQ,QAAQ,CAARA,cAAAA,CAAJ,CAAIA,CAAJ,EAAgC;AAC9B,4BAAM1B,SAAO,GAAG0B,QAAQ,CAAxB,CAAwB,CAAxB;;AACA,wBAAA,OAAI,CAAJ,eAAA,CAAA,SAAA,EAA8B,OAAI,CAAJ,kBAAA,CAA9B,8BAA8B,CAA9B;AACD;AACF;;AACD;AACD;;AAED,sBAAIH,YAAY,GAAhB,EAAA;;AACA,sBAAIL,IAAI,CAAJA,IAAAA,CAAJ,QAAA,EAAwB;AACtB,yBAAK,IAAL,EAAA,IAAgBA,IAAI,CAAJA,IAAAA,CAAhB,QAAA,EAAoC;AAClC,0BAAMM,WAAW,GAAGN,IAAI,CAAJA,IAAAA,CAAAA,QAAAA,CAApB,EAAoBA,CAApB;;AACA,0BAAI,CAACM,WAAW,CAAhB,OAAA,EAA0B;AACxB;AACD;;AACDD,sBAAAA,YAAY,CAACC,WAAW,CAAxBD,OAAY,CAAZA,GAAoCC,WAAW,CAA/CD,KAAAA;AACD;AA1BgB,mBAAA,CA6BnB;;;AACA,sBAAIwC,KAAK,GAAT,KAAA;;AAEA,sBAAI,CAAC,OAAI,CAAT,WAAA,EAAuB;AACrB,oBAAA,OAAI,CAAJ,aAAA;;AACAA,oBAAAA,KAAK,GAALA,IAAAA;AACD;;AAED,uBAAK,IAAL,GAAA,IAAA,QAAA,EAA0B;AACxB,wBAAIrC,QAAQ,CAARA,cAAAA,CAAJ,GAAIA,CAAJ,EAAgC;AAAA,0BAAA,IAAA,GAAA,YAAA;AAC9B,4BAAM1B,OAAO,GAAG0B,QAAQ,CAAxB,GAAwB,CAAxB;AACA,4BAAMxE,KAAK,GAAGqE,YAAY,CAA1B,OAA0B,CAA1B;;AAEA,4BAAI,CAAJ,KAAA,EAAY;AACV;AACA,0BAAA,OAAI,CAAJ,eAAA,CAAA,OAAA,EAA8B,OAAI,CAAJ,kBAAA,CAAA,mBAAA,EAA9B,GAA8B,CAA9B;;AACA,iCAAA,UAAA;AAHF,yBAAA,MAIO;AACL,8BAAMpC,GAAG,GAAG;AACVW,4BAAAA,MAAM,EAAE,OAAI,CAAJ,WAAA,CADE,SAAA;AAEVzC,4BAAAA,MAAM,EAAE;AACN2C,8BAAAA,OAAO,EADD,OAAA;AAEN9C,8BAAAA,KAAK,EAAEA;AAFD;AAFE,2BAAZ;;AAQA,8BAAM2B,KAAG,GAAG,OAAI,CAAJ,OAAA,CAAZ,OAAY,CAAZ;;AACA,8BAAIA,KAAG,KAAP,IAAA,EAAkB;AAChB,mCAAA,UAAA;AACD;;AAED,8BAAMgD,OAAO,GAAGhD,KAAG,CAAnB,YAAgBA,EAAhB;;AAEA,8BAAIgD,OAAO,KAAX,IAAA,EAAsB;AACpB1C,4BAAAA,GAAG,CAAHA,MAAAA,CAAAA,OAAAA,GAAAA,IAAAA;;AACA,gCAAM2C,GAAG,GAAG,OAAI,CAAJ,WAAA,CAAZ,OAAY,CAAZ;;AACA,gCAAMC,GAAG,GAAG,OAAI,CAAJ,WAAA,CAAZ,OAAY,CAAZ;;AACA,gCAAID,GAAG,IAAP,GAAA,EAAgB;AACd,kCAAA,GAAA,EAAS;AACP3C,gCAAAA,GAAG,CAAHA,MAAAA,CAAAA,GAAAA,GAAAA,GAAAA;AACD;;AACD,kCAAA,GAAA,EAAS;AACPA,gCAAAA,GAAG,CAAHA,MAAAA,CAAAA,GAAAA,GAAAA,GAAAA;AACD;AANH,6BAAA,MAOO;AACL,kCAAM6C,MAAM,GAAG,OAAI,CAAJ,cAAA,CAAf,OAAe,CAAf;;AACA,kCAAA,MAAA,EAAY;AACV7C,gCAAAA,GAAG,CAAHA,MAAAA,CAAAA,MAAAA,GAAAA,MAAAA;AACD;AACF;;AACD,gCAAM8C,KAAK,GAAG,OAAI,CAAJ,aAAA,CAAd,OAAc,CAAd;;AACA,gCAAA,KAAA,EAAW;AACT9C,8BAAAA,GAAG,CAAHA,MAAAA,CAAAA,KAAAA,GAAAA,KAAAA;AACD;AACF;;AACD,0BAAA,OAAI,CAAJ,KAAA,CAAA,GAAA,EAAA,IAAA,CAAqB,UAAA,UAAA,EAAc;AACjC,4BAAA,OAAI,CAAJ,kBAAA,CAAA,OAAA,EAAA,OAAA,EAGE,OAAI,CAAJ,QAAA,CAAA,mBAAA,CAAkC,OAAI,CAAJ,WAAA,CAAlC,SAAA,EAA8DG,UAAU,CAH1E,MAGE,CAHF;;AAKA,gCAAIA,UAAU,CAAd,IAAA,EAAqB;AACnBA,8BAAAA,UAAU,CAAVA,IAAAA;AACD;AARH,2BAAA,EASG,UAAA,SAAA,EAAa;AACd,4BAAA,OAAI,CAAJ,eAAA,CAAA,OAAA,EAA8BE,SAAS,CAAvC,KAAA;;AACA,gCAAIA,SAAS,CAAb,IAAA,EAAoB;AAClBA,8BAAAA,SAAS,CAATA,IAAAA;AACD;AAbH,2BAAA;AAeD;AA7D6B,uBAAA,EAAA;;AAAA,0BAAA,IAAA,KAAA,UAAA,EAmB1B;AA2CL;AACF;;AAED,sBAAA,KAAA,EAAW;AACT,oBAAA,OAAI,CAAJ,YAAA;AACD;AAzGH,iBAAA;;AA6GA,oBAAI,KAAA,OAAA,CAAA,kBAAA,KAAJ,IAAA,EAA8C;AAC5C,uBAAA,OAAA,CAAA,kBAAA,CAAgC;AAC9BrC,oBAAAA,IAAI,EAAEA;AADwB,mBAAhC,EAAA,EAAA;AADF,iBAAA,MAIO;AACL,sBAAMO,GAAG,GAAG,KAAA,KAAA,CACV,KAAA,OAAA,CADU,iBAAA,EACsB,KAAA,OAAA,CADtB,eAAA,EACoD,KAAA,OAAA,CADpD,gBAAA,EAAA,IAAA,EAAZ,EAAY,CAAZ;;AAEA,uBAAA,KAAA,CAAA,KAAA,IAAA,GAAA;AACD;AACF;;;wCAESsC,O,EAASgE,M,EAAQ;AACzB,oBAAMC,UAAU,GAAG,KAAA,OAAA,CAAnB,OAAmB,CAAnB;;AACA,oBAAIA,UAAU,KAAd,IAAA,EAAyB;AACvBA,kBAAAA,UAAU,CAAVA,UAAAA,CAAAA,MAAAA;;AACA,sBAAIA,UAAU,CAAd,eAAIA,EAAJ,EAAkC;AAChCA,oBAAAA,UAAU,CAAVA,SAAAA;AACD;;AACD,yBAAA,UAAA;AACD;;AACD,oBAAMpF,GAAG,GAAG,IAAIqF,aAAAA,CAAJ,SAAIA,CAAJ,CAAA,IAAA,EAAA,OAAA,EAAZ,MAAY,CAAZ;AACA,qBAAA,KAAA,CAAA,OAAA,IAAA,GAAA;AACArF,gBAAAA,GAAG,CAAHA,SAAAA;AACA,uBAAA,GAAA;AACD;;;;YAn0D6B1D,OAAAA,CAAAA,SAAAA,C;;;;;;;;;;;;;;;ACtBhC,cAAA,WAAA,GAAA,mBAAA,CAAA,GAAA,CAAA;;yBACeD,WAAAA,CAAAA,U;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDR,cAAMgD,cAAc,GAAG;AAC5BiG,YAAAA,OAAO,EADqB,CAAA;AAE5BC,YAAAA,SAAS,EAFmB,CAAA;AAG5BC,YAAAA,WAAW,EAHiB,CAAA;AAI5BC,YAAAA,OAAO,EAJqB,CAAA;AAK5BC,YAAAA,QAAQ,EALoB,CAAA;AAM5BC,YAAAA,cAAc,EANc,CAAA;AAO5BC,YAAAA,OAAO,EAPqB,CAAA;AAQ5BlB,YAAAA,IAAI,EARwB,CAAA;AAS5BmB,YAAAA,IAAI,EATwB,CAAA;AAU5BC,YAAAA,GAAG,EAVyB,CAAA;AAW5BC,YAAAA,OAAO,EAXqB,EAAA;AAY5BC,YAAAA,WAAW,EAAE;AAZe,WAAvB;;AAeA,cAAM1G,YAAY,GAAG;AAC1B2G,YAAAA,WAAW,EADe,CAAA;AAE1BC,YAAAA,IAAI,EAFsB,CAAA;AAG1BC,YAAAA,KAAK,EAHqB,CAAA;AAI1BC,YAAAA,KAAK,EAJqB,CAAA;AAK1BC,YAAAA,OAAO,EALmB,CAAA;AAM1BC,YAAAA,GAAG,EAAE;AANqB,WAArB;;;cASM/G,W;;;;;;;6CACIU,Q,EAAU;AACvB,uBAAO,QAAQ,CAAR,GAAA,CAAa,UAAA,CAAA,EAAC;AAAA,yBAAIrB,IAAI,CAAJA,SAAAA,CAAJ,CAAIA,CAAJ;AAAd,iBAAA,EAAA,IAAA,CAAP,IAAO,CAAP;AACD;;;;;;;;cAGUY,W;;;;;;;4CACGlB,I,EAAM;AAClB,uBAAO,IAAI,CAAJ,KAAA,CAAA,IAAA,EAAA,MAAA,CAAwB,UAAA,CAAA,EAAC;AAAA,yBAAIiI,CAAC,KAAL,EAAA;AAAzB,iBAAA,EAAA,GAAA,CAA2C,UAAA,CAAA,EAAC;AAAA,yBAAI3H,IAAI,CAAJA,KAAAA,CAAJ,CAAIA,CAAJ;AAAnD,iBAAO,CAAP;AACD;;;kDAEmB4H,U,EAAYlI,I,EAAM;AACpC,uBAAA,IAAA;AACD;;;yCAEUA,I,EAAM;AACf,uBAAA,IAAA;AACD;;;6CAEcmI,Q,EAAUnI,I,EAAM;AAC7B,uBAAA,IAAA;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CH,cAAA,OAAA,GAAA,sBAAA,CAAA,mBAAA,CAAA,GAAA,CAAA,CAAA;;AAEA,cAAA,MAAA,GAAA,mBAAA,CAAA,GAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,cAAMoI,UAAU,GAAhB,CAAA;AACA,cAAMC,kBAAkB,GAAxB,CAAA;AACA,cAAMC,cAAc,GAApB,CAAA;AACA,cAAMC,YAAY,GAAlB,CAAA;AACA,cAAMC,mBAAmB,GAAzB,CAAA;;cAEqBzB,Y;;;;;AACnB,qBAAA,YAAA,CAAA,UAAA,EAAA,OAAA,EAAA,MAAA,EAAyC;AAAA,kBAAA,KAAA;;AAAA,cAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;;AACvC,cAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA;AACA,cAAA,KAAA,CAAA,OAAA,GAAA,OAAA;AACA,cAAA,KAAA,CAAA,WAAA,GAAA,UAAA;AACA,cAAA,KAAA,CAAA,OAAA,GAAA,UAAA;AACA,cAAA,KAAA,CAAA,MAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,cAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,MAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,oBAAA,GAAA,IAAA;AACA,cAAA,KAAA,CAAA,cAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,YAAA,GAAA,KAAA;AACA,cAAA,KAAA,CAAA,QAAA,GAAA,KAAA;;AACA,cAAA,KAAA,CAAA,UAAA,CAAA,MAAA;;AACA,cAAA,KAAA,CAAA,kBAAA;;AACA,cAAA,KAAA,CAAA,SAAA,GAAA,EAAA;AACA,cAAA,KAAA,CAAA,UAAA,GAAA,CAAA;;AACA,cAAA,KAAA,CAAA,EAAA,CAAA,OAAA,EAAiB,UAAA,UAAA,EAAsB;AACrC,qBAAA,WAAA,CAAA,MAAA,CAAA,oBAAA,EAAA,UAAA;AADF,eAAA;;AAhBuC,qBAAA,KAAA;AAmBxC;;;;+CAEgB;AACf,uBAAO,EAAE,KAAT,UAAA;AACD;;;mDAEoB;AAAA,oBAAA,MAAA,GAAA,IAAA,CAAA,CACnB;AACA;AACA;;;AACA,qBAAA,MAAA,GAAA,KAAA;AAEA,qBAAA,oBAAA,GAA4B,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAAqB;AAC3D,kBAAA,MAAI,CAAJ,QAAA,GAAgB,UAAA,KAAA,EAAS;AACvB,oBAAA,MAAI,CAAJ,MAAA,GAAA,IAAA;AACA/D,oBAAAA,OAAO,CAAPA,KAAO,CAAPA;AAFF,mBAAA;;AAIA,kBAAA,MAAI,CAAJ,OAAA,GAAe,UAAA,GAAA,EAAO;AACpB,oBAAA,MAAI,CAAJ,MAAA,GAAA,IAAA;AACAC,oBAAAA,MAAM,CAANA,GAAM,CAANA;AAFF,mBAAA;AAL0B,iBAAA,EAAA,IAAA,CASpB,YAAY,CATQ,CAAA,EASJ,YAAY,CATpC,CAA4B,CAA5B;AAUD;;;6CAEc;AACb,uBAAO,KAAA,YAAA,KAAA,IAAA,IAA8B,KAAA,QAAA,KAArC,IAAA;AACD;;;yCAEU4D,M,EAAQ;AACjB,oBAAI,CAAJ,MAAA,EAAa;AACX;AACD;;AACD,oBAAI,CAAA,GAAA,MAAA,CAAA,UAAA,EAAJ,MAAI,CAAJ,EAAwB;AACtB;AACA,uBAAA,EAAA,CAAA,SAAA,EAAA,MAAA;AAFF,iBAAA,MAGO,IAAI4B,MAAM,CAANA,SAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAAAA,MAAAA,MAA2CA,MAAM,CAANA,SAAAA,CAAAA,QAAAA,CAAAA,IAAAA,CAA/C,EAA+CA,CAA/C,EAAmF;AACxF,sBAAMC,WAAW,GAAG,CAAA,SAAA,EAAA,MAAA,EAAA,OAAA,EAAA,aAAA,EAAA,WAAA,EAApB,OAAoB,CAApB;;AACA,uBAAK,IAAIlF,CAAC,GAAL,CAAA,EAAWmF,CAAC,GAAGD,WAAW,CAA/B,MAAA,EAAwClF,CAAC,GAAzC,CAAA,EAA+CA,CAA/C,EAAA,EAAoD;AAClD,wBAAMoF,EAAE,GAAGF,WAAW,CAAtB,CAAsB,CAAtB;;AACA,wBAAIE,EAAE,IAAN,MAAA,EAAkB;AAChB,2BAAA,EAAA,CAAA,EAAA,EAAY/B,MAAM,CAAlB,EAAkB,CAAlB;AACD;AACF;AACF;AACF;;;uCAEQ;AACP,uBAAO,KAAA,OAAA,KAAP,UAAA;AACD;;;gDAEiB;AAChB,uBAAO,KAAA,OAAA,KAAP,mBAAA;AACD;;;+CAEgB;AACf,uBAAO,KAAA,OAAA,KAAP,kBAAA;AACD;;;yCAEU;AACT,uBAAO,KAAA,OAAA,KAAA,cAAA,IAAmC,KAAA,OAAA,KAA1C,YAAA;AACD;;;2CAEY;AACX,uBAAO,KAAA,OAAA,KAAP,cAAA;AACD;;;yCAEU;AACT,uBAAO,KAAA,OAAA,KAAP,YAAA;AACD;;;wCAES;AACR,qBAAA,OAAA,GAAA,UAAA;AACD;;;8CAEepC,a,EAAe;AAC7B,qBAAA,cAAA,GAAsBA,aAAa,IAAnC,KAAA;;AACA,oBAAI,KAAA,MAAA,KAAJ,IAAA,EAA0B;AACxB;AACA,uBAAA,kBAAA;AACD;;AACD,qBAAA,OAAA,GAAA,kBAAA;AACD;;;mDAEoBoE,e,EAAiB;AACpC,oBAAI,KAAA,OAAA,KAAJ,cAAA,EAAqC;AACnC;AACD;;AACD,qBAAA,OAAA,GAAA,cAAA;;AACA,oBAAMC,cAAc,GAAG,KAAA,2BAAA,CAAvB,eAAuB,CAAvB;;AACA,qBAAA,QAAA,GAAA,KAAA;AACA,qBAAA,IAAA,CAAA,WAAA,EAAA,cAAA;;AACA,qBAAA,QAAA,CAAA,cAAA;;AACA,qBAAK,IAAL,EAAA,IAAiB,KAAjB,SAAA,EAAiC;AAC/BtH,kBAAAA,YAAY,CAAC,KAAA,SAAA,CAAA,EAAA,EAAbA,OAAY,CAAZA;;AACA,uBAAA,SAAA,CAAA,EAAA,EAAA,OAAA;;AACA,yBAAO,KAAA,SAAA,CAAP,EAAO,CAAP;AACD;AACF;;;iDAEkBY,G,EAAK;AACtB,oBAAI,KAAA,OAAA,KAAJ,YAAA,EAAmC;AACjC;AACD;;AACD,qBAAA,OAAA,GAAA,YAAA;AACA,qBAAA,MAAA,GAAA,GAAA;;AACA,oBAAM2G,UAAU,GAAG,KAAnB,yBAAmB,EAAnB;;AACA,qBAAA,IAAA,CAAA,OAAA,EAAA,UAAA;;AACA,qBAAA,OAAA,CAAA,UAAA;;AACA,qBAAK,IAAL,EAAA,IAAiB,KAAjB,SAAA,EAAiC;AAC/BvH,kBAAAA,YAAY,CAAC,KAAA,SAAA,CAAA,EAAA,EAAbA,OAAY,CAAZA;;AACA,uBAAA,SAAA,CAAA,EAAA,EAAA,MAAA,CAAA,GAAA;;AACA,yBAAO,KAAA,SAAA,CAAP,EAAO,CAAP;AACD;AACF;;;oDAEqB;AACpB,qBAAA,IAAA,CAAA,aAAA,EAAyB;AACvBqB,kBAAAA,OAAO,EAAE,KAAKA;AADS,iBAAzB;AAGD;;;+CAEgBmG,a,EAAe;AAC9B,qBAAA,WAAA,CAAA,uBAAA,CAAyC,KAAzC,OAAA;;AACA,oBAAI,KAAA,OAAA,KAAJ,mBAAA,EAA0C;AACxC;AACD;;AACD,oBAAMC,WAAW,GAAG,KAAA,OAAA,KAApB,cAAA;AACA,qBAAA,OAAA,GAAA,mBAAA;;AACA,oBAAID,aAAa,KAAjB,IAAA,EAA4B;AAC1B,uBAAA,QAAA,GAAA,KAAA;AACA,uBAAA,cAAA,GAAA,IAAA;AACA,yBAAO,KAAA,WAAA,CAAA,QAAA,CAA0B,KAAjC,OAAO,CAAP;AACA,yBAAO,KAAA,WAAA,CAAA,QAAA,CAA0B,KAAjC,OAAO,CAAP;AACA,yBAAO,KAAA,WAAA,CAAA,UAAA,CAA4B,KAAnC,OAAO,CAAP;AACD;;AACD,oBAAA,WAAA,EAAiB;AACf,uBAAA,mBAAA;AACD;AACF;;;mDAEoB;AACnB,uBAAO,CAAC,KAAR,cAAA;AACD;;;0DAE2BH,e,EAAiB;AAC3C,oBAAI3D,GAAG,GAAG;AACRrC,kBAAAA,OAAO,EAAE,KADD,OAAA;AAER4B,kBAAAA,aAAa,EAAE,KAAKyE;AAFZ,iBAAV;;AAIA,oBAAA,eAAA,EAAqB;AACnB;AACAhE,kBAAAA,GAAG,GAAG,KAAA,WAAA,CAAA,uBAAA,CAAA,GAAA,EAANA,eAAM,CAANA;AACD;;AACD,uBAAA,GAAA;AACD;;;0DAE2B;AAC1B,oBAAMiE,qBAAqB,GAAG,KAA9B,MAAA;AACAA,gBAAAA,qBAAqB,CAArBA,OAAAA,GAAgC,KAAhCA,OAAAA;AACAA,gBAAAA,qBAAqB,CAArBA,aAAAA,GAAsC,KAAtCA,cAAAA;AACA,uBAAA,qBAAA;AACD;;;oCAEK/I,Q,EAAUqB,O,EAAS;AACvB,oBAAI,KAAJ,MAAA,EAAiB;AACf,sBAAI,KAAJ,UAAI,EAAJ,EAAuB;AACrBrB,oBAAAA,QAAQ,CAAC,KAATA,2BAAS,EAAD,CAARA;AADF,mBAAA,MAEO;AACLqB,oBAAAA,OAAO,CAAC,KAARA,yBAAQ,EAAD,CAAPA;AACD;AACF;AACF;;;0CAEW;AACV,oBAAI,KAAA,OAAA,KAAJ,cAAA,EAAqC;AACnC;AACD;;AACD,qBAAA,cAAA,GAAA,KAAA;;AACA,qBAAA,WAAA,CAAA,UAAA,CAAA,IAAA;AACD;;;4CAEa;AACZ,qBAAA,gBAAA,CAAA,IAAA;;AACA,qBAAA,WAAA,CAAA,YAAA,CAAA,IAAA;AACD;;;4CAEa;AAAA,oBAAA,MAAA,GAAA,IAAA;;AACZ,oBAAI,KAAJ,UAAI,EAAJ,EAAuB;AACrB,yBAAOxD,OAAO,CAAd,OAAOA,EAAP;AADF,iBAAA,MAEO,IAAI,KAAJ,QAAI,EAAJ,EAAqB;AAC1B,yBAAOA,OAAO,CAAPA,MAAAA,CAAe,KAAtB,MAAOA,CAAP;AACD;;AACD,oBAAImL,UAAU,GAAG,IAAA,OAAA,CAAY,UAAA,GAAA,EAAA,GAAA,EAAc;AACzC,sBAAM1K,OAAO,GAAGmC,UAAU,CAAC,YAAY;AACrCwI,oBAAAA,GAAG,CAAC;AAAC,8BAAD,CAAA;AAAY,iCAAW;AAAvB,qBAAD,CAAHA;AADwB,mBAAA,EAEvB,MAAI,CAAJ,WAAA,CAAA,OAAA,CAFH,OAA0B,CAA1B;AAGA,kBAAA,MAAI,CAAJ,SAAA,CAAe,MAAI,CAAnB,cAAe,EAAf,IAAwC;AACtC3K,oBAAAA,OAAO,EAD+B,OAAA;AAEtCsE,oBAAAA,OAAO,EAF+B,GAAA;AAGtCC,oBAAAA,MAAM,EAAEoG;AAH8B,mBAAxC;AAJF,iBAAiB,CAAjB;AAUA,uBAAA,UAAA;AACD;;;sCAEOrJ,I,EAAM;AACZ,oBAAMsJ,IAAI,GAAV,IAAA;AACA,uBAAO,KAAA,WAAA,GAAA,IAAA,CAAwB,YAAY;AACzC,yBAAOA,IAAI,CAAJA,WAAAA,CAAAA,OAAAA,CAAyBA,IAAI,CAA7BA,OAAAA,EAAP,IAAOA,CAAP;AADF,iBAAO,CAAP;AAGD;;;yCAEU;AACT,oBAAMA,IAAI,GAAV,IAAA;AACA,uBAAO,KAAA,WAAA,GAAA,IAAA,CAAwB,YAAY;AACzC,yBAAOA,IAAI,CAAJA,WAAAA,CAAAA,QAAAA,CAA0BA,IAAI,CAArC,OAAOA,CAAP;AADF,iBAAO,CAAP;AAGD;;;8CAEe;AACd,oBAAMA,IAAI,GAAV,IAAA;AACA,uBAAO,KAAA,WAAA,GAAA,IAAA,CAAwB,YAAY;AACzC,yBAAOA,IAAI,CAAJA,WAAAA,CAAAA,aAAAA,CAA+BA,IAAI,CAA1C,OAAOA,CAAP;AADF,iBAAO,CAAP;AAGD;;;sCAEOxG,O,EAAS;AACf,oBAAMwG,IAAI,GAAV,IAAA;AACA,uBAAO,KAAA,WAAA,GAAA,IAAA,CAAwB,YAAY;AACzC,yBAAOA,IAAI,CAAJA,WAAAA,CAAAA,OAAAA,CAAyBA,IAAI,CAA7BA,OAAAA,EAAP,OAAOA,CAAP;AADF,iBAAO,CAAP;AAGD;;;;YA3PuCtL,OAAAA,CAAAA,SAAAA,C;;;;;;;;;;;;;;;;;;;;;ACZnC,mBAAA,UAAA,CAAA,KAAA,EAAA,MAAA,EAAmC;AACxC,mBAAOuL,KAAK,CAALA,WAAAA,CAAAA,MAAAA,EAAAA,CAAAA,MAAP,CAAA;AACD;;AAAA;;AAEM,mBAAA,UAAA,CAAA,KAAA,EAA2B;AAChC,gBAAIA,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAAhC,IAAA,EAA2C;AACzC,qBAAA,KAAA;AACD;;AACD,mBAAO,OAAA,KAAA,KAAP,UAAA;AACD;;AAAA;;AAEM,mBAAA,GAAA,CAAA,KAAA,EAAA,IAAA,EAA0B;AAC/B,gBAAI/I,mBAAAA,CAAAA,CAAAA,CAAJ,OAAA,EAAoB;AAClB,kBAAMgJ,MAAM,GAAGhJ,mBAAAA,CAAAA,CAAAA,CAAAA,OAAAA,CAAf,KAAeA,CAAf;;AAEA,kBAAIiJ,UAAU,CAAd,MAAc,CAAd,EAAwB;AACtBD,gBAAAA,MAAM,CAANA,KAAAA,CAAahJ,mBAAAA,CAAAA,CAAAA,CAAbgJ,OAAAA,EAAAA,IAAAA;AACD;AACF;AACF;;AAAA;;AAEM,mBAAA,OAAA,CAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAiC;AACtC,gBAAMxF,MAAM,GAAG,MAAMC,IAAI,CAAzB,MAAqBA,EAArB;AACA,gBAAM5C,QAAQ,GAAG4C,IAAI,CAAJA,GAAAA,CAAAA,GAAAA,EAAcyF,GAAG,GAAGzF,IAAI,CAAJA,GAAAA,CAAAA,CAAAA,EAAY0F,IAAI,GAArD,CAAqC1F,CAApBA,CAAjB;AAEA,mBAAOA,IAAI,CAAJA,KAAAA,CAAW,CAAC,IAAD,MAAA,IAAlB,QAAOA,CAAP;AACD;;AAAA;;AAEM,mBAAA,WAAA,CAAA,IAAA,EAA2B;AAChC,mBAAO,WAAA,IAAA,IAAmBjE,IAAI,CAAJA,KAAAA,KAA1B,IAAA;AACD;;AAAA;;AAEM,mBAAA,MAAA,CAAA,CAAA,EAAA,CAAA,EAAsB;AAC3B,iBAAK,IAAL,GAAA,IAAA,CAAA,EAAqB;AACnB,kBAAI4J,CAAC,CAADA,cAAAA,CAAJ,GAAIA,CAAJ,EAA2B;AACzBC,gBAAAA,CAAC,CAADA,GAAC,CAADA,GAASD,CAAC,CAAVC,GAAU,CAAVA;AACD;AACF;;AACD,mBAAA,CAAA;AACD;;AAAA;;;;;;;;ACvCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA,cAAA,CAAA,GAAA,OAAA,OAAA,KAAA,QAAA,GAAA,OAAA,GAAA,IAAA;AACA,cAAA,YAAA,GAAA,CAAA,IAAA,OAAA,CAAA,CAAA,KAAA,KAAA,UAAA,GACA,CAAA,CAAA,KADA,GAEA,SAAA,YAAA,CAAA,MAAA,EAAA,QAAA,EAAA,IAAA,EAAA;AACA,mBAAA,QAAA,CAAA,SAAA,CAAA,KAAA,CAAA,IAAA,CAAA,MAAA,EAAA,QAAA,EAAA,IAAA,CAAA;AACA,WAJA;AAMA,cAAA,cAAA;;AACA,cAAA,CAAA,IAAA,OAAA,CAAA,CAAA,OAAA,KAAA,UAAA,EAAA;AACA,YAAA,cAAA,GAAA,CAAA,CAAA,OAAA;AACC,WAFD,MAEC,IAAA,MAAA,CAAA,qBAAA,EAAA;AACD,YAAA,cAAA,GAAA,SAAA,cAAA,CAAA,MAAA,EAAA;AACA,qBAAA,MAAA,CAAA,mBAAA,CAAA,MAAA,EACA,MADA,CACA,MAAA,CAAA,qBAAA,CAAA,MAAA,CADA,CAAA;AAEA,aAHA;AAIC,WALA,MAKA;AACD,YAAA,cAAA,GAAA,SAAA,cAAA,CAAA,MAAA,EAAA;AACA,qBAAA,MAAA,CAAA,mBAAA,CAAA,MAAA,CAAA;AACA,aAFA;AAGA;;AAEA,mBAAA,kBAAA,CAAA,OAAA,EAAA;AACA,gBAAA,OAAA,IAAA,OAAA,CAAA,IAAA,EAAA,OAAA,CAAA,IAAA,CAAA,OAAA;AACA;;AAEA,cAAA,WAAA,GAAA,MAAA,CAAA,KAAA,IAAA,SAAA,WAAA,CAAA,KAAA,EAAA;AACA,mBAAA,KAAA,KAAA,KAAA;AACA,WAFA;;AAIA,mBAAA,YAAA,GAAA;AACA,YAAA,YAAA,CAAA,IAAA,CAAA,IAAA,CAAA,IAAA;AACA;;AACA,UAAA,MAAA,CAAA,OAAA,GAAA,YAAA;AACA,UAAA,MAAA,CAAA,OAAA,CAAA,IAAA,GAAmB,IAAnB,C,CAEA;;AACA,UAAA,YAAA,CAAA,YAAA,GAAA,YAAA;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,OAAA,GAAA,SAAA;AACA,UAAA,YAAA,CAAA,SAAA,CAAA,YAAA,GAAA,CAAA;AACA,UAAA,YAAA,CAAA,SAAA,CAAA,aAAA,GAAA,SAAA,C,CAEA;AACA;;AACA,cAAA,mBAAA,GAAA,EAAA;;AAEA,mBAAA,aAAA,CAAA,QAAA,EAAA;AACA,gBAAA,OAAA,QAAA,KAAA,UAAA,EAAA;AACA,oBAAA,IAAA,SAAA,CAAA,qEAAA,OAAA,QAAA,CAAA;AACA;AACA;;AAEA,UAAA,MAAA,CAAA,cAAA,CAAA,YAAA,EAAA,qBAAA,EAAA;AACA,YAAA,UAAA,EAAA,IADA;AAEA,YAAA,GAAA,EAAA,eAAA;AACA,qBAAA,mBAAA;AACG,aAJH;AAKA,YAAA,GAAA,EAAA,aAAA,GAAA,EAAA;AACA,kBAAA,OAAA,GAAA,KAAA,QAAA,IAAA,GAAA,GAAA,CAAA,IAAA,WAAA,CAAA,GAAA,CAAA,EAAA;AACA,sBAAA,IAAA,UAAA,CAAA,oGAAA,GAAA,GAAA,GAAA,CAAA;AACA;;AACA,cAAA,mBAAA,GAAA,GAAA;AACA;AAVA,WAAA;;AAaA,UAAA,YAAA,CAAA,IAAA,GAAA,YAAA;AAEA,gBAAA,KAAA,OAAA,KAAA,SAAA,IACA,KAAA,OAAA,KAAA,MAAA,CAAA,cAAA,CAAA,IAAA,EAAA,OADA,EACA;AACA,mBAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA;AACA,mBAAA,YAAA,GAAA,CAAA;AACA;;AAEA,iBAAA,aAAA,GAAA,KAAA,aAAA,IAAA,SAAA;AACA,WATA,C,CAWA;AACA;;;AACA,UAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GAAA,SAAA,eAAA,CAAA,CAAA,EAAA;AACA,gBAAA,OAAA,CAAA,KAAA,QAAA,IAAA,CAAA,GAAA,CAAA,IAAA,WAAA,CAAA,CAAA,CAAA,EAAA;AACA,oBAAA,IAAA,UAAA,CAAA,kFAAA,CAAA,GAAA,GAAA,CAAA;AACA;;AACA,iBAAA,aAAA,GAAA,CAAA;AACA,mBAAA,IAAA;AACA,WANA;;AAQA,mBAAA,gBAAA,CAAA,IAAA,EAAA;AACA,gBAAA,IAAA,CAAA,aAAA,KAAA,SAAA,EACA,OAAA,YAAA,CAAA,mBAAA;AACA,mBAAA,IAAA,CAAA,aAAA;AACA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GAAA,SAAA,eAAA,GAAA;AACA,mBAAA,gBAAA,CAAA,IAAA,CAAA;AACA,WAFA;;AAIA,UAAA,YAAA,CAAA,SAAA,CAAA,IAAA,GAAA,SAAA,IAAA,CAAA,IAAA,EAAA;AACA,gBAAA,IAAA,GAAA,EAAA;;AACA,iBAAA,IAAA,CAAA,GAAA,CAAA,EAAiB,CAAA,GAAA,SAAA,CAAA,MAAjB,EAAuC,CAAA,EAAvC;AAAuC,cAAA,IAAA,CAAA,IAAA,CAAA,SAAA,CAAA,CAAA,CAAA;AAAvC;;AACA,gBAAA,OAAA,GAAA,IAAA,KAAA,OAAA;AAEA,gBAAA,MAAA,GAAA,KAAA,OAAA;AACA,gBAAA,MAAA,KAAA,SAAA,EACA,OAAA,GAAA,OAAA,IAAA,MAAA,CAAA,KAAA,KAAA,SAAA,CADA,KAEA,IAAA,CAAA,OAAA,EACA,OAAA,KAAA,CATA,CAWA;;AACA,gBAAA,OAAA,EAAA;AACA,kBAAA,EAAA;AACA,kBAAA,IAAA,CAAA,MAAA,GAAA,CAAA,EACA,EAAA,GAAA,IAAA,CAAA,CAAA,CAAA;;AACA,kBAAA,EAAA,YAAA,KAAA,EAAA;AACA;AACA;AACA,sBAAA,EAAA,CAHA,CAGe;AACf,eARA,CASA;;;AACA,kBAAA,GAAA,GAAA,IAAA,KAAA,CAAA,sBAAA,EAAA,GAAA,OAAA,EAAA,CAAA,OAAA,GAAA,GAAA,GAAA,EAAA,CAAA,CAAA;AACA,cAAA,GAAA,CAAA,OAAA,GAAA,EAAA;AACA,oBAAA,GAAA,CAZA,CAYc;AACd;;AAEA,gBAAA,OAAA,GAAA,MAAA,CAAA,IAAA,CAAA;AAEA,gBAAA,OAAA,KAAA,SAAA,EACA,OAAA,KAAA;;AAEA,gBAAA,OAAA,OAAA,KAAA,UAAA,EAAA;AACA,cAAA,YAAA,CAAA,OAAA,EAAA,IAAA,EAAA,IAAA,CAAA;AACG,aAFH,MAEG;AACH,kBAAA,GAAA,GAAA,OAAA,CAAA,MAAA;AACA,kBAAA,SAAA,GAAA,UAAA,CAAA,OAAA,EAAA,GAAA,CAAA;;AACA,mBAAA,IAAA,CAAA,GAAA,CAAA,EAAmB,CAAA,GAAA,GAAnB,EAA4B,EAAA,CAA5B;AACA,gBAAA,YAAA,CAAA,SAAA,CAAA,CAAA,CAAA,EAAA,IAAA,EAAA,IAAA,CAAA;AADA;AAEA;;AAEA,mBAAA,IAAA;AACA,WA1CA;;AA4CA,mBAAA,YAAA,CAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAAA,OAAA,EAAA;AACA,gBAAA,CAAA;AACA,gBAAA,MAAA;AACA,gBAAA,QAAA;AAEA,YAAA,aAAA,CAAA,QAAA,CAAA;AAEA,YAAA,MAAA,GAAA,MAAA,CAAA,OAAA;;AACA,gBAAA,MAAA,KAAA,SAAA,EAAA;AACA,cAAA,MAAA,GAAA,MAAA,CAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA;AACA,cAAA,MAAA,CAAA,YAAA,GAAA,CAAA;AACG,aAHH,MAGG;AACH;AACA;AACA,kBAAA,MAAA,CAAA,WAAA,KAAA,SAAA,EAAA;AACA,gBAAA,MAAA,CAAA,IAAA,CAAA,aAAA,EAAA,IAAA,EACA,QAAA,CAAA,QAAA,GAAA,QAAA,CAAA,QAAA,GAAA,QADA,EADA,CAIA;AACA;;AACA,gBAAA,MAAA,GAAA,MAAA,CAAA,OAAA;AACA;;AACA,cAAA,QAAA,GAAA,MAAA,CAAA,IAAA,CAAA;AACA;;AAEA,gBAAA,QAAA,KAAA,SAAA,EAAA;AACA;AACA,cAAA,QAAA,GAAA,MAAA,CAAA,IAAA,CAAA,GAAA,QAAA;AACA,gBAAA,MAAA,CAAA,YAAA;AACG,aAJH,MAIG;AACH,kBAAA,OAAA,QAAA,KAAA,UAAA,EAAA;AACA;AACA,gBAAA,QAAA,GAAA,MAAA,CAAA,IAAA,CAAA,GACA,OAAA,GAAA,CAAA,QAAA,EAAA,QAAA,CAAA,GAAA,CAAA,QAAA,EAAA,QAAA,CADA,CAFA,CAIA;AACK,eALL,MAKK,IAAA,OAAA,EAAA;AACL,gBAAA,QAAA,CAAA,OAAA,CAAA,QAAA;AACK,eAFA,MAEA;AACL,gBAAA,QAAA,CAAA,IAAA,CAAA,QAAA;AACA,eAVG,CAYH;;;AACA,cAAA,CAAA,GAAA,gBAAA,CAAA,MAAA,CAAA;;AACA,kBAAA,CAAA,GAAA,CAAA,IAAA,QAAA,CAAA,MAAA,GAAA,CAAA,IAAA,CAAA,QAAA,CAAA,MAAA,EAAA;AACA,gBAAA,QAAA,CAAA,MAAA,GAAA,IAAA,CADA,CAEA;AACA;;AACA,oBAAA,CAAA,GAAA,IAAA,KAAA,CAAA,iDACA,QAAA,CAAA,MADA,GACA,GADA,GACA,MAAA,CAAA,IAAA,CADA,GACA,aADA,GAEA,0CAFA,GAGA,gBAHA,CAAA;AAIA,gBAAA,CAAA,CAAA,IAAA,GAAA,6BAAA;AACA,gBAAA,CAAA,CAAA,OAAA,GAAA,MAAA;AACA,gBAAA,CAAA,CAAA,IAAA,GAAA,IAAA;AACA,gBAAA,CAAA,CAAA,KAAA,GAAA,QAAA,CAAA,MAAA;AACA,gBAAA,kBAAA,CAAA,CAAA,CAAA;AACA;AACA;;AAEA,mBAAA,MAAA;AACA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,WAAA,GAAA,SAAA,WAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACA,mBAAA,YAAA,CAAA,IAAA,EAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA;AACA,WAFA;;AAIA,UAAA,YAAA,CAAA,SAAA,CAAA,EAAA,GAAA,YAAA,CAAA,SAAA,CAAA,WAAA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GACA,SAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACA,mBAAA,YAAA,CAAA,IAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,CAAA;AACA,WAHA;;AAKA,mBAAA,WAAA,GAAA;AACA,gBAAA,CAAA,KAAA,KAAA,EAAA;AACA,mBAAA,MAAA,CAAA,cAAA,CAAA,KAAA,IAAA,EAAA,KAAA,MAAA;AACA,mBAAA,KAAA,GAAA,IAAA;AACA,kBAAA,SAAA,CAAA,MAAA,KAAA,CAAA,EACA,OAAA,KAAA,QAAA,CAAA,IAAA,CAAA,KAAA,MAAA,CAAA;AACA,qBAAA,KAAA,QAAA,CAAA,KAAA,CAAA,KAAA,MAAA,EAAA,SAAA,CAAA;AACA;AACA;;AAEA,mBAAA,SAAA,CAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAAA;AACA,gBAAA,KAAA,GAAA;AAAe,cAAA,KAAA,EAAA,KAAf;AAAe,cAAA,MAAA,EAAA,SAAf;AAAe,cAAA,MAAA,EAAA,MAAf;AAAe,cAAA,IAAA,EAAA,IAAf;AAAe,cAAA,QAAA,EAAA;AAAf,aAAA;AACA,gBAAA,OAAA,GAAA,WAAA,CAAA,IAAA,CAAA,KAAA,CAAA;AACA,YAAA,OAAA,CAAA,QAAA,GAAA,QAAA;AACA,YAAA,KAAA,CAAA,MAAA,GAAA,OAAA;AACA,mBAAA,OAAA;AACA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,IAAA,GAAA,SAAA,IAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACA,YAAA,aAAA,CAAA,QAAA,CAAA;AACA,iBAAA,EAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,EAAA,IAAA,EAAA,QAAA,CAAA;AACA,mBAAA,IAAA;AACA,WAJA;;AAMA,UAAA,YAAA,CAAA,SAAA,CAAA,mBAAA,GACA,SAAA,mBAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACA,YAAA,aAAA,CAAA,QAAA,CAAA;AACA,iBAAA,eAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,EAAA,IAAA,EAAA,QAAA,CAAA;AACA,mBAAA,IAAA;AACA,WALA,C,CAOA;;;AACA,UAAA,YAAA,CAAA,SAAA,CAAA,cAAA,GACA,SAAA,cAAA,CAAA,IAAA,EAAA,QAAA,EAAA;AACA,gBAAA,IAAA,EAAA,MAAA,EAAA,QAAA,EAAA,CAAA,EAAA,gBAAA;AAEA,YAAA,aAAA,CAAA,QAAA,CAAA;AAEA,YAAA,MAAA,GAAA,KAAA,OAAA;AACA,gBAAA,MAAA,KAAA,SAAA,EACA,OAAA,IAAA;AAEA,YAAA,IAAA,GAAA,MAAA,CAAA,IAAA,CAAA;AACA,gBAAA,IAAA,KAAA,SAAA,EACA,OAAA,IAAA;;AAEA,gBAAA,IAAA,KAAA,QAAA,IAAA,IAAA,CAAA,QAAA,KAAA,QAAA,EAAA;AACA,kBAAA,EAAA,KAAA,YAAA,KAAA,CAAA,EACA,KAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CADA,KAEA;AACA,uBAAA,MAAA,CAAA,IAAA,CAAA;AACA,oBAAA,MAAA,CAAA,cAAA,EACA,KAAA,IAAA,CAAA,gBAAA,EAAA,IAAA,EAAA,IAAA,CAAA,QAAA,IAAA,QAAA;AACA;AACO,aARP,MAQO,IAAA,OAAA,IAAA,KAAA,UAAA,EAAA;AACP,cAAA,QAAA,GAAA,CAAA,CAAA;;AAEA,mBAAA,CAAA,GAAA,IAAA,CAAA,MAAA,GAAA,CAAA,EAAiC,CAAA,IAAA,CAAjC,EAAyC,CAAA,EAAzC,EAAyC;AACzC,oBAAA,IAAA,CAAA,CAAA,CAAA,KAAA,QAAA,IAAA,IAAA,CAAA,CAAA,CAAA,CAAA,QAAA,KAAA,QAAA,EAAA;AACA,kBAAA,gBAAA,GAAA,IAAA,CAAA,CAAA,CAAA,CAAA,QAAA;AACA,kBAAA,QAAA,GAAA,CAAA;AACA;AACA;AACA;;AAEA,kBAAA,QAAA,GAAA,CAAA,EACA,OAAA,IAAA;AAEA,kBAAA,QAAA,KAAA,CAAA,EACA,IAAA,CAAA,KAAA,GADA,KAEA;AACA,gBAAA,SAAA,CAAA,IAAA,EAAA,QAAA,CAAA;AACA;AAEA,kBAAA,IAAA,CAAA,MAAA,KAAA,CAAA,EACA,MAAA,CAAA,IAAA,CAAA,GAAA,IAAA,CAAA,CAAA,CAAA;AAEA,kBAAA,MAAA,CAAA,cAAA,KAAA,SAAA,EACA,KAAA,IAAA,CAAA,gBAAA,EAAA,IAAA,EAAA,gBAAA,IAAA,QAAA;AACA;;AAEA,mBAAA,IAAA;AACA,WAlDA;;AAoDA,UAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,YAAA,CAAA,SAAA,CAAA,cAAA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,kBAAA,GACA,SAAA,kBAAA,CAAA,IAAA,EAAA;AACA,gBAAA,SAAA,EAAA,MAAA,EAAA,CAAA;AAEA,YAAA,MAAA,GAAA,KAAA,OAAA;AACA,gBAAA,MAAA,KAAA,SAAA,EACA,OAAA,IAAA,CALA,CAOA;;AACA,gBAAA,MAAA,CAAA,cAAA,KAAA,SAAA,EAAA;AACA,kBAAA,SAAA,CAAA,MAAA,KAAA,CAAA,EAAA;AACA,qBAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA;AACA,qBAAA,YAAA,GAAA,CAAA;AACS,eAHT,MAGS,IAAA,MAAA,CAAA,IAAA,CAAA,KAAA,SAAA,EAAA;AACT,oBAAA,EAAA,KAAA,YAAA,KAAA,CAAA,EACA,KAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA,CADA,KAGA,OAAA,MAAA,CAAA,IAAA,CAAA;AACA;;AACA,qBAAA,IAAA;AACA,aAnBA,CAqBA;;;AACA,gBAAA,SAAA,CAAA,MAAA,KAAA,CAAA,EAAA;AACA,kBAAA,IAAA,GAAA,MAAA,CAAA,IAAA,CAAA,MAAA,CAAA;AACA,kBAAA,GAAA;;AACA,mBAAA,CAAA,GAAA,CAAA,EAAmB,CAAA,GAAA,IAAA,CAAA,MAAnB,EAAoC,EAAA,CAApC,EAAoC;AACpC,gBAAA,GAAA,GAAA,IAAA,CAAA,CAAA,CAAA;AACA,oBAAA,GAAA,KAAA,gBAAA,EAAA;AACA,qBAAA,kBAAA,CAAA,GAAA;AACA;;AACA,mBAAA,kBAAA,CAAA,gBAAA;AACA,mBAAA,OAAA,GAAA,MAAA,CAAA,MAAA,CAAA,IAAA,CAAA;AACA,mBAAA,YAAA,GAAA,CAAA;AACA,qBAAA,IAAA;AACA;;AAEA,YAAA,SAAA,GAAA,MAAA,CAAA,IAAA,CAAA;;AAEA,gBAAA,OAAA,SAAA,KAAA,UAAA,EAAA;AACA,mBAAA,cAAA,CAAA,IAAA,EAAA,SAAA;AACO,aAFP,MAEO,IAAA,SAAA,KAAA,SAAA,EAAA;AACP;AACA,mBAAA,CAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,EAAsC,CAAA,IAAA,CAAtC,EAA8C,CAAA,EAA9C,EAA8C;AAC9C,qBAAA,cAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA,CAAA;AACA;AACA;;AAEA,mBAAA,IAAA;AACA,WAjDA;;AAmDA,mBAAA,UAAA,CAAA,MAAA,EAAA,IAAA,EAAA,MAAA,EAAA;AACA,gBAAA,MAAA,GAAA,MAAA,CAAA,OAAA;AAEA,gBAAA,MAAA,KAAA,SAAA,EACA,OAAA,EAAA;AAEA,gBAAA,UAAA,GAAA,MAAA,CAAA,IAAA,CAAA;AACA,gBAAA,UAAA,KAAA,SAAA,EACA,OAAA,EAAA;AAEA,gBAAA,OAAA,UAAA,KAAA,UAAA,EACA,OAAA,MAAA,GAAA,CAAA,UAAA,CAAA,QAAA,IAAA,UAAA,CAAA,GAAA,CAAA,UAAA,CAAA;AAEA,mBAAA,MAAA,GACA,eAAA,CAAA,UAAA,CADA,GACA,UAAA,CAAA,UAAA,EAAA,UAAA,CAAA,MAAA,CADA;AAEA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,SAAA,GAAA,SAAA,SAAA,CAAA,IAAA,EAAA;AACA,mBAAA,UAAA,CAAA,IAAA,EAAA,IAAA,EAAA,IAAA,CAAA;AACA,WAFA;;AAIA,UAAA,YAAA,CAAA,SAAA,CAAA,YAAA,GAAA,SAAA,YAAA,CAAA,IAAA,EAAA;AACA,mBAAA,UAAA,CAAA,IAAA,EAAA,IAAA,EAAA,KAAA,CAAA;AACA,WAFA;;AAIA,UAAA,YAAA,CAAA,aAAA,GAAA,UAAA,OAAA,EAAA,IAAA,EAAA;AACA,gBAAA,OAAA,OAAA,CAAA,aAAA,KAAA,UAAA,EAAA;AACA,qBAAA,OAAA,CAAA,aAAA,CAAA,IAAA,CAAA;AACG,aAFH,MAEG;AACH,qBAAA,aAAA,CAAA,IAAA,CAAA,OAAA,EAAA,IAAA,CAAA;AACA;AACA,WANA;;AAQA,UAAA,YAAA,CAAA,SAAA,CAAA,aAAA,GAAA,aAAA;;AACA,mBAAA,aAAA,CAAA,IAAA,EAAA;AACA,gBAAA,MAAA,GAAA,KAAA,OAAA;;AAEA,gBAAA,MAAA,KAAA,SAAA,EAAA;AACA,kBAAA,UAAA,GAAA,MAAA,CAAA,IAAA,CAAA;;AAEA,kBAAA,OAAA,UAAA,KAAA,UAAA,EAAA;AACA,uBAAA,CAAA;AACK,eAFL,MAEK,IAAA,UAAA,KAAA,SAAA,EAAA;AACL,uBAAA,UAAA,CAAA,MAAA;AACA;AACA;;AAEA,mBAAA,CAAA;AACA;;AAEA,UAAA,YAAA,CAAA,SAAA,CAAA,UAAA,GAAA,SAAA,UAAA,GAAA;AACA,mBAAA,KAAA,YAAA,GAAA,CAAA,GAAA,cAAA,CAAA,KAAA,OAAA,CAAA,GAAA,EAAA;AACA,WAFA;;AAIA,mBAAA,UAAA,CAAA,GAAA,EAAA,CAAA,EAAA;AACA,gBAAA,IAAA,GAAA,IAAA,KAAA,CAAA,CAAA,CAAA;;AACA,iBAAA,IAAA,CAAA,GAAA,CAAA,EAAiB,CAAA,GAAA,CAAjB,EAAwB,EAAA,CAAxB;AACA,cAAA,IAAA,CAAA,CAAA,CAAA,GAAA,GAAA,CAAA,CAAA,CAAA;AADA;;AAEA,mBAAA,IAAA;AACA;;AAEA,mBAAA,SAAA,CAAA,IAAA,EAAA,KAAA,EAAA;AACA,mBAAQ,KAAA,GAAA,CAAA,GAAA,IAAA,CAAA,MAAR,EAAiC,KAAA,EAAjC;AACA,cAAA,IAAA,CAAA,KAAA,CAAA,GAAA,IAAA,CAAA,KAAA,GAAA,CAAA,CAAA;AADA;;AAEA,YAAA,IAAA,CAAA,GAAA;AACA;;AAEA,mBAAA,eAAA,CAAA,GAAA,EAAA;AACA,gBAAA,GAAA,GAAA,IAAA,KAAA,CAAA,GAAA,CAAA,MAAA,CAAA;;AACA,iBAAA,IAAA,CAAA,GAAA,CAAA,EAAiB,CAAA,GAAA,GAAA,CAAA,MAAjB,EAAiC,EAAA,CAAjC,EAAiC;AACjC,cAAA,GAAA,CAAA,CAAA,CAAA,GAAA,GAAA,CAAA,CAAA,CAAA,CAAA,QAAA,IAAA,GAAA,CAAA,CAAA,CAAA;AACA;;AACA,mBAAA,GAAA;AACA;;AAEA,mBAAA,IAAA,CAAA,OAAA,EAAA,IAAA,EAAA;AACA,mBAAA,IAAA,OAAA,CAAA,UAAA,OAAA,EAAA,MAAA,EAAA;AACA,uBAAA,aAAA,GAAA;AACA,oBAAA,aAAA,KAAA,SAAA,EAAA;AACA,kBAAA,OAAA,CAAA,cAAA,CAAA,OAAA,EAAA,aAAA;AACA;;AACA,gBAAA,OAAA,CAAA,GAAA,KAAA,CAAA,IAAA,CAAA,SAAA,CAAA,CAAA;AACA;;AAAA;AACA,kBAAA,aAAA,CAPA,CASA;AACA;AACA;AACA;AACA;AACA;;AACA,kBAAA,IAAA,KAAA,OAAA,EAAA;AACA,gBAAA,aAAA,GAAA,SAAA,aAAA,CAAA,GAAA,EAAA;AACA,kBAAA,OAAA,CAAA,cAAA,CAAA,IAAA,EAAA,aAAA;AACA,kBAAA,MAAA,CAAA,GAAA,CAAA;AACA,iBAHA;;AAKA,gBAAA,OAAA,CAAA,IAAA,CAAA,OAAA,EAAA,aAAA;AACA;;AAEA,cAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,aAAA;AACG,aAzBH,CAAA;AA0BA;;;;;;;;;;AC3dA;;;;AACA,UAAA,wBAAA,GAAA,EAAA;;;;AAEA;;;;AACA,eAAA,mBAAA,CAAA,QAAA,EAAA;AACA;AAAA;;AACA;AAAA,YAAA,wBAAA,CAAA,QAAA,CAAA,EAAA;AACA;AAAA,iBAAA,wBAAA,CAAA,QAAA,CAAA,CAAA,OAAA;AACA;AAAA;AACA;AAAA;;AACA;;;AAAA,YAAA,MAAA,GAAA,wBAAA,CAAA,QAAA,CAAA,GAAA;AACA;AAAA;;AACA;AAAA;;AACA;AAAA,UAAA,OAAA,EAAA;AACA;;AAJA,SAAA;;;AAMA;AAAA;;AACA;;AAAA,QAAA,mBAAA,CAAA,QAAA,CAAA,CAAA,MAAA,EAAA,MAAA,CAAA,OAAA,EAAA,mBAAA;;;AAEA;AAAA;;AACA;;;AAAA,eAAA,MAAA,CAAA,OAAA;AACA;AAAA;;;;;;;;;;;;;;ACrBA,QAAA,mBAAA,CAAA,CAAA,GAAA,YAAA;AACA;AAAA,cAAA,OAAA,UAAA,KAAA,QAAA,EAAA,OAAA,UAAA;AACA;;AAAA,cAAA;AACA;AAAA,mBAAA,QAAA,IAAA,QAAA,CAAA,aAAA,GAAA;AACA;AAAE,WAFF,CAEE,OAAA,CAAA,EAAA;AACF;AAAA,gBAAA,OAAA,MAAA,KAAA,QAAA,EAAA,OAAA,MAAA;AACA;AAAA;AACA;;AAAC,SAPD,EAAA;;;;;;;;;ACAA;;;AACA;;;AACA;;;;AACA,aAAA,mBAAA,CAAA,GAAA,CAAA;;;ATOA;CAVA","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Centrifuge\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Centrifuge\"] = factory();\n\telse\n\t\troot[\"Centrifuge\"] = factory();\n})(this, function() {\nreturn ","import EventEmitter from 'events';\nimport Subscription from './subscription';\n\nimport {\n  JsonEncoder,\n  JsonDecoder,\n  JsonMethodType,\n  JsonPushType\n} from './json';\n\nimport {\n  isFunction,\n  log,\n  startsWith,\n  errorExists,\n  backoff,\n  extend\n} from './utils';\n\nconst _errorTimeout = 'timeout';\nconst _errorConnectionClosed = 'connection closed';\n\nexport class Centrifuge extends EventEmitter {\n\n  constructor(url, options) {\n    super();\n    this._url = url;\n    this._websocket = null;\n    this._sockjs = null;\n    this._isSockjs = false;\n    this._xmlhttprequest = null;\n    this._binary = false;\n    this._methodType = null;\n    this._pushType = null;\n    this._encoder = null;\n    this._decoder = null;\n    this._status = 'disconnected';\n    this._reconnect = true;\n    this._reconnecting = false;\n    this._transport = null;\n    this._transportName = null;\n    this._transportClosed = true;\n    this._messageId = 0;\n    this._clientID = null;\n    this._refreshRequired = false;\n    this._subs = {};\n    this._serverSubs = {};\n    this._lastSeq = {};\n    this._lastGen = {};\n    this._lastOffset = {};\n    this._lastEpoch = {};\n    this._messages = [];\n    this._isBatching = false;\n    this._isSubscribeBatching = false;\n    this._privateChannels = {};\n    this._numRefreshFailed = 0;\n    this._refreshTimeout = null;\n    this._pingTimeout = null;\n    this._pongTimeout = null;\n    this._subRefreshTimeouts = {};\n    this._retries = 0;\n    this._callbacks = {};\n    this._latency = null;\n    this._latencyStart = null;\n    this._connectData = null;\n    this._token = null;\n    this._xhrID = 0;\n    this._xhrs = {};\n    this._dispatchPromise = Promise.resolve();\n    this._config = {\n      debug: false,\n      name: '',\n      version: '',\n      websocket: null,\n      sockjs: null,\n      xmlhttprequest: null,\n      minRetry: 1000,\n      maxRetry: 20000,\n      timeout: 5000,\n      ping: true,\n      pingInterval: 25000,\n      pongWaitTimeout: 5000,\n      privateChannelPrefix: '$',\n      onTransportClose: null,\n      sockjsServer: null,\n      sockjsTransports: [\n        'websocket',\n        'xdr-streaming',\n        'xhr-streaming',\n        'eventsource',\n        'iframe-eventsource',\n        'iframe-htmlfile',\n        'xdr-polling',\n        'xhr-polling',\n        'iframe-xhr-polling',\n        'jsonp-polling'\n      ],\n      refreshEndpoint: '/centrifuge/refresh',\n      refreshHeaders: {},\n      refreshParams: {},\n      refreshData: {},\n      refreshAttempts: null,\n      refreshInterval: 1000,\n      onRefreshFailed: null,\n      onRefresh: null,\n      subscribeEndpoint: '/centrifuge/subscribe',\n      subscribeHeaders: {},\n      subscribeParams: {},\n      subRefreshInterval: 1000,\n      onPrivateSubscribe: null\n    };\n    this._configure(options);\n  }\n\n  setToken(token) {\n    this._token = token;\n  }\n\n  setConnectData(data) {\n    this._connectData = data;\n  }\n\n  setRefreshHeaders(headers) {\n    this._config.refreshHeaders = headers;\n  }\n  setRefreshParams(params) {\n    this._config.refreshParams = params;\n  }\n  setRefreshData(data) {\n    this._config.refreshData = data;\n  }\n\n  setSubscribeHeaders(headers) {\n    this._config.subscribeHeaders = headers;\n  }\n  setSubscribeParams(params) {\n    this._config.subscribeParams = params;\n  }\n\n  _ajax(url, params, headers, data, callback) {\n    let query = '';\n    this._debug('sending AJAX request to', url, 'with data', JSON.stringify(data));\n\n    let xhr;\n    if (this._xmlhttprequest !== null) {\n      // use explicitly passed XMLHttpRequest object.\n      xhr = new this._xmlhttprequest();\n    } else {\n      xhr = (global.XMLHttpRequest ? new global.XMLHttpRequest() : new global.ActiveXObject('Microsoft.XMLHTTP'));\n    }\n\n    for (const i in params) {\n      if (params.hasOwnProperty(i)) {\n        if (query.length > 0) {\n          query += '&';\n        }\n        query += encodeURIComponent(i) + '=' + encodeURIComponent(params[i]);\n      }\n    }\n    if (query.length > 0) {\n      query = '?' + query;\n    }\n    xhr.open('POST', url + query, true);\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n    xhr.setRequestHeader('Content-Type', 'application/json');\n    for (const headerName in headers) {\n      if (headers.hasOwnProperty(headerName)) {\n        xhr.setRequestHeader(headerName, headers[headerName]);\n      }\n    }\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === 4) {\n        if (xhr.status === 200) {\n          let data, parsed = false;\n          try {\n            data = JSON.parse(xhr.responseText);\n            parsed = true;\n          } catch (e) {\n            callback({\n              error: 'Invalid JSON. Data was: ' + xhr.responseText,\n              status: 200,\n              data: null\n            });\n          }\n          if (parsed) { // prevents double execution.\n            callback({\n              data: data,\n              status: 200\n            });\n          }\n        } else {\n          this._log('wrong status code in AJAX response', xhr.status);\n          callback({\n            status: xhr.status,\n            data: null\n          });\n        }\n      }\n    };\n    setTimeout(() => xhr.send(JSON.stringify(data)), 20);\n    return xhr;\n  };\n\n  _log() {\n    log('info', arguments);\n  };\n\n  _debug() {\n    if (this._config.debug === true) {\n      log('debug', arguments);\n    }\n  };\n\n  _websocketSupported() {\n    if (this._config.websocket !== null) {\n      return true;\n    }\n    return !(typeof WebSocket !== 'function' && typeof WebSocket !== 'object');\n  };\n\n  _setFormat(format) {\n    if (this._formatOverride(format)) {\n      return;\n    }\n    if (format === 'protobuf') {\n      throw new Error('not implemented by JSON only Centrifuge client â€“ use client with Protobuf');\n    }\n    this._binary = false;\n    this._methodType = JsonMethodType;\n    this._pushType = JsonPushType;\n    this._encoder = new JsonEncoder();\n    this._decoder = new JsonDecoder();\n  }\n\n  _formatOverride(format) {\n    return false;\n  }\n\n  _configure(configuration) {\n    if (!('Promise' in global)) {\n      throw new Error('Promise polyfill required');\n    }\n\n    extend(this._config, configuration || {});\n    this._debug('centrifuge config', this._config);\n\n    if (!this._url) {\n      throw new Error('url required');\n    }\n\n    if (startsWith(this._url, 'ws') && this._url.indexOf('format=protobuf') > -1) {\n      this._setFormat('protobuf');\n    } else {\n      this._setFormat('json');\n    }\n\n    if (startsWith(this._url, 'http')) {\n      this._debug('client will try to connect to SockJS endpoint');\n      if (this._config.sockjs !== null) {\n        this._debug('SockJS explicitly provided in options');\n        this._sockjs = this._config.sockjs;\n      } else {\n        if (typeof global.SockJS === 'undefined') {\n          throw new Error('SockJS not found, use ws:// in url or include SockJS');\n        }\n        this._debug('use globally defined SockJS');\n        this._sockjs = global.SockJS;\n      }\n    } else {\n      this._debug('client will connect to websocket endpoint');\n    }\n\n    this._xmlhttprequest = this._config.xmlhttprequest;\n  };\n\n  _setStatus(newStatus) {\n    if (this._status !== newStatus) {\n      this._debug('Status', this._status, '->', newStatus);\n      this._status = newStatus;\n    }\n  };\n\n  _isDisconnected() {\n    return this._status === 'disconnected';\n  };\n\n  _isConnecting() {\n    return this._status === 'connecting';\n  };\n\n  _isConnected() {\n    return this._status === 'connected';\n  };\n\n  _nextMessageId() {\n    return ++this._messageId;\n  };\n\n  _resetRetry() {\n    this._debug('reset retries count to 0');\n    this._retries = 0;\n  };\n\n  _getRetryInterval() {\n    const interval = backoff(this._retries, this._config.minRetry, this._config.maxRetry);\n\n    this._retries += 1;\n    return interval;\n  };\n\n  _abortInflightXHRs() {\n    for (const xhrID in this._xhrs) {\n      try {\n        this._xhrs[xhrID].abort();\n      } catch (e) {\n        this._debug('error aborting xhr', e);\n      }\n      delete this._xhrs[xhrID];\n    }\n  };\n\n  _clearConnectedState(reconnect) {\n    this._clientID = null;\n    this._stopPing();\n\n    // fire errbacks of registered outgoing calls.\n    for (const id in this._callbacks) {\n      if (this._callbacks.hasOwnProperty(id)) {\n        const callbacks = this._callbacks[id];\n        clearTimeout(callbacks.timeout);\n        const errback = callbacks.errback;\n        if (!errback) {\n          continue;\n        }\n        errback({error: this._createErrorObject('disconnected')});\n      }\n    }\n    this._callbacks = {};\n\n    // fire unsubscribe events\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n\n        if (reconnect) {\n          if (sub._isSuccess()) {\n            sub._triggerUnsubscribe();\n            sub._recover = true;\n          }\n          if (sub._shouldResubscribe()) {\n            sub._setSubscribing();\n          }\n        } else {\n          sub._setUnsubscribed();\n        }\n      }\n    }\n\n    this._abortInflightXHRs();\n\n    // clear refresh timer\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    // clear sub refresh timers\n    for (const channel in this._subRefreshTimeouts) {\n      if (this._subRefreshTimeouts.hasOwnProperty(channel) && this._subRefreshTimeouts[channel]) {\n        this._clearSubRefreshTimeout(channel);\n      }\n    }\n    this._subRefreshTimeouts = {};\n\n    if (!this._reconnect) {\n      // completely clear subscriptions\n      this._subs = {};\n    }\n  };\n\n  _isTransportOpen() {\n    if (this._isSockjs) {\n      return this._transport &&\n        this._transport.transport &&\n        this._transport.transport.readyState === this._transport.transport.OPEN;\n    }\n    return this._transport && this._transport.readyState === this._transport.OPEN;\n  };\n\n  _transportSend(commands) {\n    if (!commands.length) {\n      return true;\n    }\n\n    if (!this._isTransportOpen()) {\n      // resolve pending commands with error if transport is not open\n      for (let command in commands) {\n        let id = command.id;\n        if (!(id in this._callbacks)) {\n          continue;\n        }\n        const callbacks = this._callbacks[id];\n        clearTimeout(this._callbacks[id].timeout);\n        delete this._callbacks[id];\n        const errback = callbacks.errback;\n        errback({error: this._createErrorObject(_errorConnectionClosed, 0)});\n      }\n      return false;\n    }\n    this._transport.send(this._encoder.encodeCommands(commands));\n    return true;\n  }\n\n  _setupTransport() {\n    this._isSockjs = false;\n\n    // detect transport to use - SockJS or Websocket\n    if (this._sockjs !== null) {\n      const sockjsOptions = {\n        transports: this._config.sockjsTransports\n      };\n\n      if (this._config.sockjsServer !== null) {\n        sockjsOptions.server = this._config.sockjsServer;\n      }\n      this._isSockjs = true;\n      this._transport = new this._sockjs(this._url, null, sockjsOptions);\n    } else {\n      if (!this._websocketSupported()) {\n        this._debug('No Websocket support and no SockJS configured, can not connect');\n        return;\n      }\n      if (this._config.websocket !== null) {\n        this._websocket = this._config.websocket;\n      } else {\n        this._websocket = WebSocket;\n      }\n      this._transport = new this._websocket(this._url);\n      if (this._binary === true) {\n        this._transport.binaryType = 'arraybuffer';\n      }\n    }\n\n    this._transport.onopen = () => {\n      this._transportClosed = false;\n\n      if (this._isSockjs) {\n        this._transportName = 'sockjs-' + this._transport.transport;\n        this._transport.onheartbeat = () => this._restartPing();\n      } else {\n        this._transportName = 'websocket';\n      }\n\n      // Can omit method here due to zero value.\n      const msg = {\n        // method: this._methodType.CONNECT\n      };\n\n      if (this._token || this._connectData || this._config.name || this._config.version) {\n        msg.params = {};\n      }\n      if (this._token) {\n        msg.params.token = this._token;\n      }\n      if (this._connectData) {\n        msg.params.data = this._connectData;\n      }\n      if (this._config.name) {\n        msg.params.name = this._config.name;\n      }\n      if (this._config.version) {\n        msg.params.version = this._config.version;\n      }\n\n      let subs = {};\n      let hasSubs = false;\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel) && this._serverSubs[channel].recoverable) {\n          hasSubs = true;\n          let sub = {\n            'recover': true\n          };\n          if (this._serverSubs[channel].seq || this._serverSubs[channel].gen) {\n            if (this._serverSubs[channel].seq) {\n              sub['seq'] = this._serverSubs[channel].seq;\n            }\n            if (this._serverSubs[channel].gen) {\n              sub['gen'] = this._serverSubs[channel].gen;\n            }\n          } else {\n            if (this._serverSubs[channel].offset) {\n              sub['offset'] = this._serverSubs[channel].offset;\n            }\n          }\n          if (this._serverSubs[channel].epoch) {\n            sub['epoch'] = this._serverSubs[channel].epoch;\n          }\n          subs[channel] = sub;\n        }\n      }\n      if (hasSubs) {\n        if (!msg.params) {msg.params = {};}\n        msg.params.subs = subs;\n      }\n\n      this._latencyStart = new Date();\n      this._call(msg).then(resolveCtx => {\n        this._connectResponse(this._decoder.decodeCommandResult(this._methodType.CONNECT, resolveCtx.result), hasSubs);\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        const err = rejectCtx.error;\n        if (err.code === 109) { // token expired.\n          this._refreshRequired = true;\n        }\n        this._disconnect('connect error', true);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    this._transport.onerror = error => {\n      this._debug('transport level error', error);\n    };\n\n    this._transport.onclose = closeEvent => {\n      this._transportClosed = true;\n      let reason = _errorConnectionClosed;\n      let needReconnect = true;\n\n      if (closeEvent && 'reason' in closeEvent && closeEvent.reason) {\n        try {\n          const advice = JSON.parse(closeEvent.reason);\n          this._debug('reason is an advice object', advice);\n          reason = advice.reason;\n          needReconnect = advice.reconnect;\n        } catch (e) {\n          reason = closeEvent.reason;\n          this._debug('reason is a plain string', reason);\n        }\n      }\n\n      // onTransportClose callback should be executed every time transport was closed.\n      // This can be helpful to catch failed connection events (because our disconnect\n      // event only called once and every future attempts to connect do not fire disconnect\n      // event again).\n      if (this._config.onTransportClose !== null) {\n        this._config.onTransportClose({\n          event: closeEvent,\n          reason: reason,\n          reconnect: needReconnect\n        });\n      }\n\n      this._disconnect(reason, needReconnect);\n\n      if (this._reconnect === true) {\n        this._reconnecting = true;\n        const interval = this._getRetryInterval();\n\n        this._debug('reconnect after ' + interval + ' milliseconds');\n        setTimeout(() => {\n          if (this._reconnect === true) {\n            if (this._refreshRequired) {\n              this._refresh();\n            } else {\n              this._connect();\n            }\n          }\n        }, interval);\n      }\n    };\n\n    this._transport.onmessage = event => {\n      this._dataReceived(event.data);\n    };\n  };\n\n  rpc(data) {\n    return this._rpc('', data);\n  }\n\n  namedRPC(method, data) {\n    return this._rpc(method, data);\n  }\n\n  _rpc(method, data) {\n    let params = {\n      data: data\n    };\n    if (method !== '') {\n      params.method = method;\n    };\n    const msg = {\n      method: this._methodType.RPC,\n      params: params\n    };\n    return this._methodCall(msg, function (result) {\n      return result;\n    });\n  }\n\n  send(data) {\n    const msg = {\n      method: this._methodType.SEND,\n      params: {\n        data: data\n      }\n    };\n\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n\n    const sent = this._transportSend([msg]); // can send async message to server without id set\n    if (!sent) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    };\n    return Promise.resolve({});\n  }\n\n  _getHistoryParams(channel, options) {\n    let params = {\n      channel: channel\n    };\n    if (options !== undefined) {\n      if (options.since) {\n        params['use_since'] = true;\n        if (options.since.offset) {\n          params['offset'] = options.since.offset;\n        }\n        if (options.since.epoch) {\n          params['epoch'] = options.since.epoch;\n        }\n      };\n      if (options.limit !== undefined) {\n        params['use_limit'] = true;\n        params['limit'] = options.limit;\n      }\n    };\n    return params;\n  }\n\n  _methodCall(msg, resultCB) {\n    if (!this.isConnected()) {\n      return Promise.reject(this._createErrorObject(_errorConnectionClosed, 0));\n    }\n    return new Promise((resolve, reject) => {\n      this._call(msg).then(resolveCtx => {\n        resolve(resultCB(this._decoder.decodeCommandResult(msg.method, resolveCtx.result)));\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        reject(rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    });\n  }\n\n  publish(channel, data) {\n    const msg = {\n      method: this._methodType.PUBLISH,\n      params: {\n        channel: channel,\n        data: data\n      }\n    };\n    return this._methodCall(msg, function () {\n      return {};\n    });\n  }\n\n  history(channel, options) {\n    const params = this._getHistoryParams(channel, options);\n    const msg = {\n      method: this._methodType.HISTORY,\n      params: params\n    };\n    return this._methodCall(msg, function (result) {\n      return {\n        'publications': result.publications,\n        'epoch': result.epoch || '',\n        'offset': result.offset || 0\n      };\n    });\n  }\n\n  presence(channel) {\n    const msg = {\n      method: this._methodType.PRESENCE,\n      params: {\n        channel: channel\n      }\n    };\n    return this._methodCall(msg, function (result) {\n      return {\n        'presence': result.presence\n      };\n    });\n  }\n\n  presenceStats(channel) {\n    const msg = {\n      method: this._methodType.PRESENCE_STATS,\n      params: {\n        channel: channel\n      }\n    };\n    return this._methodCall(msg, function (result) {\n      return {\n        'num_users': result.num_users,\n        'num_clients': result.num_clients\n      };\n    });\n  }\n\n  _dataReceived(data) {\n    const replies = this._decoder.decodeReplies(data);\n    // we have to guarantee order of events in replies processing - i.e. start processing\n    // next reply only when we finished processing of current one. Without syncing things in\n    // this way we could get wrong publication events order as reply promises resolve\n    // on next loop tick so for loop continues before we finished emitting all reply events.\n    this._dispatchPromise = this._dispatchPromise.then(() => {\n      let finishDispatch;\n      this._dispatchPromise = new Promise(resolve =>{\n        finishDispatch = resolve;\n      });\n      this._dispatchSynchronized(replies, finishDispatch);\n    });\n    this._restartPing();\n  }\n\n  _dispatchSynchronized(replies, finishDispatch) {\n    let p = Promise.resolve();\n    for (const i in replies) {\n      if (replies.hasOwnProperty(i)) {\n        p = p.then(() => {\n          return this._dispatchReply(replies[i]);\n        });\n      }\n    }\n    p = p.then(() => {\n      finishDispatch();\n    });\n  }\n\n  _dispatchReply(reply) {\n    var next;\n    const p = new Promise(resolve =>{\n      next = resolve;\n    });\n\n    if (reply === undefined || reply === null) {\n      this._debug('dispatch: got undefined or null reply');\n      next();\n      return p;\n    }\n\n    const id = reply.id;\n\n    if (id && id > 0) {\n      this._handleReply(reply, next);\n    } else {\n      this._handlePush(reply.result, next);\n    }\n\n    return p;\n  };\n\n  _call(msg) {\n    return new Promise((resolve, reject) => {\n      const id = this._addMessage(msg);\n      this._registerCall(id, resolve, reject);\n    });\n  }\n\n  _connect() {\n    if (this.isConnected()) {\n      this._debug('connect called when already connected');\n      return;\n    }\n    if (this._status === 'connecting') {\n      return;\n    }\n\n    this._debug('start connecting');\n    this._setStatus('connecting');\n    this._clientID = null;\n    this._reconnect = true;\n    this._setupTransport();\n  };\n\n  _disconnect(reason, shouldReconnect) {\n\n    const reconnect = shouldReconnect || false;\n    if (reconnect === false) {\n      this._reconnect = false;\n    }\n\n    if (this._isDisconnected()) {\n      if (!reconnect) {\n        this._clearConnectedState(reconnect);\n      }\n      return;\n    }\n\n    this._clearConnectedState(reconnect);\n\n    this._debug('disconnected:', reason, shouldReconnect);\n    this._setStatus('disconnected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (this._reconnecting === false) {\n      // fire unsubscribe events for server side subs.\n      for (const channel in this._serverSubs) {\n        if (this._serverSubs.hasOwnProperty(channel)) {\n          this.emit('unsubscribe', {channel: channel});\n        }\n      }\n      this.emit('disconnect', {\n        reason: reason,\n        reconnect: reconnect\n      });\n    }\n\n    if (reconnect === false) {\n      this._subs = {};\n      this._serverSubs = {};\n    }\n\n    if (!this._transportClosed) {\n      this._transport.close();\n    }\n  };\n\n  _refreshFailed() {\n    this._numRefreshFailed = 0;\n    if (!this._isDisconnected()) {\n      this._disconnect('refresh failed', false);\n    }\n    if (this._config.onRefreshFailed !== null) {\n      this._config.onRefreshFailed();\n    }\n  };\n\n  _refresh() {\n    // ask application for new connection token.\n    this._debug('refresh token');\n\n    if (this._config.refreshAttempts === 0) {\n      this._debug('refresh attempts set to 0, do not send refresh request at all');\n      this._refreshFailed();\n      return;\n    }\n\n    if (this._refreshTimeout !== null) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        // We don't perform any connection status related actions here as we are\n        // relying on server that must close connection eventually.\n        if (resp.error) {\n          this._debug('error refreshing connection token', resp.error);\n        } else {\n          this._debug('error refreshing connection token: wrong status code', resp.status);\n        }\n        this._numRefreshFailed++;\n        if (this._refreshTimeout !== null) {\n          clearTimeout(this._refreshTimeout);\n          this._refreshTimeout = null;\n        }\n        if (this._config.refreshAttempts !== null && this._numRefreshFailed >= this._config.refreshAttempts) {\n          this._refreshFailed();\n          return;\n        }\n        const jitter = Math.round(Math.random() * 1000 * Math.max(this._numRefreshFailed, 20));\n        const interval = this._config.refreshInterval + jitter;\n        this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n        return;\n      }\n      this._numRefreshFailed = 0;\n      this._token = resp.data.token;\n      if (!this._token) {\n        this._refreshFailed();\n        return;\n      }\n      if (this._isDisconnected() && this._reconnect) {\n        this._debug('token refreshed, connect from scratch');\n        this._connect();\n      } else {\n        this._debug('send refreshed token');\n        const msg = {\n          method: this._methodType.REFRESH,\n          params: {\n            token: this._token\n          }\n        };\n        this._call(msg).then(resolveCtx => {\n          this._refreshResponse(this._decoder.decodeCommandResult(this._methodType.REFRESH, resolveCtx.result));\n          if (resolveCtx.next) {\n            resolveCtx.next();\n          }\n        }, rejectCtx => {\n          this._refreshError(rejectCtx.error);\n          if (rejectCtx.next) {\n            rejectCtx.next();\n          }\n        });\n      }\n    };\n\n    if (this._config.onRefresh !== null) {\n      const context = {};\n      this._config.onRefresh(context, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.refreshEndpoint,\n        this._config.refreshParams,\n        this._config.refreshHeaders,\n        this._config.refreshData,\n        cb\n      );\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _refreshError(err) {\n    this._debug('refresh error', err);\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    const interval = this._config.refreshInterval + Math.round(Math.random() * 1000);\n    this._refreshTimeout = setTimeout(() => this._refresh(), interval);\n  }\n\n  _refreshResponse(result) {\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n      this._refreshTimeout = null;\n    }\n    if (result.expires) {\n      this._clientID = result.client;\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n  };\n\n  _newXHRID() {\n    this._xhrID++;\n    return this._xhrID;\n  }\n\n  _subRefresh(channel) {\n    this._debug('refresh subscription token for channel', channel);\n\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      this._clearSubRefreshTimeout(channel);\n    } else {\n      return;\n    }\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (resp.error || resp.status !== 200 || this._clientID !== clientID) {\n        return;\n      }\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      const token = channelsData[channel];\n      if (!token) {\n        return;\n      }\n      const msg = {\n        method: this._methodType.SUB_REFRESH,\n        params: {\n          channel: channel,\n          token: token\n        }\n      };\n\n      const sub = this._getSub(channel);\n      if (sub === null) {\n        return;\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subRefreshResponse(\n          channel,\n          this._decoder.decodeCommandResult(this._methodType.SUB_REFRESH, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subRefreshError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    };\n\n    const data = {\n      client: this._clientID,\n      channels: [channel]\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  _clearSubRefreshTimeout(channel) {\n    if (this._subRefreshTimeouts[channel] !== undefined) {\n      clearTimeout(this._subRefreshTimeouts[channel]);\n      delete this._subRefreshTimeouts[channel];\n    }\n  }\n\n  _subRefreshError(channel, err) {\n    this._debug('subscription refresh error', channel, err);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    const jitter = Math.round(Math.random() * 1000);\n    let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._config.subRefreshInterval + jitter);\n    this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    return;\n  }\n\n  _subRefreshResponse(channel, result) {\n    this._debug('subscription refresh success', channel);\n    this._clearSubRefreshTimeout(channel);\n    const sub = this._getSub(channel);\n    if (sub === null) {\n      return;\n    }\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n    return;\n  };\n\n  _subscribe(sub, isResubscribe) {\n    this._debug('subscribing on', sub.channel);\n    const channel = sub.channel;\n\n    if (!(channel in this._subs)) {\n      this._subs[channel] = sub;\n    }\n\n    if (!this.isConnected()) {\n      // subscribe will be called later\n      sub._setNew();\n      return;\n    }\n\n    sub._setSubscribing(isResubscribe);\n\n    const msg = {\n      method: this._methodType.SUBSCRIBE,\n      params: {\n        channel: channel\n      }\n    };\n\n    // If channel name does not start with privateChannelPrefix - then we\n    // can just send subscription message to Centrifuge. If channel name\n    // starts with privateChannelPrefix - then this is a private channel\n    // and we should ask web application backend for permission first.\n    if (startsWith(channel, this._config.privateChannelPrefix)) {\n      // private channel.\n      if (this._isSubscribeBatching) {\n        this._privateChannels[channel] = true;\n      } else {\n        this.startSubscribeBatching();\n        this._subscribe(sub);\n        this.stopSubscribeBatching();\n      }\n    } else {\n      const recover = sub._needRecover();\n\n      if (recover === true) {\n        msg.params.recover = true;\n        const seq = this._getLastSeq(channel);\n        const gen = this._getLastGen(channel);\n        if (seq || gen) {\n          if (seq) {\n            msg.params.seq = seq;\n          }\n          if (gen) {\n            msg.params.gen = gen;\n          }\n        } else {\n          const offset = this._getLastOffset(channel);\n          if (offset) {\n            msg.params.offset = offset;\n          }\n        }\n        const epoch = this._getLastEpoch(channel);\n        if (epoch) {\n          msg.params.epoch = epoch;\n        }\n      }\n\n      this._call(msg).then(resolveCtx => {\n        this._subscribeResponse(\n          channel,\n          recover,\n          this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n        );\n        if (resolveCtx.next) {\n          resolveCtx.next();\n        }\n      }, rejectCtx => {\n        this._subscribeError(channel, rejectCtx.error);\n        if (rejectCtx.next) {\n          rejectCtx.next();\n        }\n      });\n    }\n  };\n\n  _unsubscribe(sub) {\n    delete this._subs[sub.channel];\n    delete this._lastOffset[sub.channel];\n    delete this._lastSeq[sub.channel];\n    delete this._lastGen[sub.channel];\n    if (this.isConnected()) {\n      // No need to unsubscribe in disconnected state - i.e. client already unsubscribed.\n      this._addMessage({\n        method: this._methodType.UNSUBSCRIBE,\n        params: {\n          channel: sub.channel\n        }\n      });\n    }\n  };\n\n  _getTTLMilliseconds(ttl) {\n    // https://stackoverflow.com/questions/12633405/what-is-the-maximum-delay-for-setinterval\n    return Math.min(ttl * 1000, 2147483647);\n  }\n\n  getSub(channel) {\n    return this._getSub(channel);\n  }\n\n  _getSub(channel) {\n    const sub = this._subs[channel];\n    if (!sub) {\n      return null;\n    }\n    return sub;\n  };\n\n  _isServerSub(channel) {\n    return this._serverSubs[channel] !== undefined;\n  };\n\n  _connectResponse(result, isRecover) {\n    const wasReconnecting = this._reconnecting;\n    this._reconnecting = false;\n    this._resetRetry();\n    this._refreshRequired = false;\n\n    if (this.isConnected()) {\n      return;\n    }\n\n    if (this._latencyStart !== null) {\n      this._latency = (new Date()).getTime() - this._latencyStart.getTime();\n      this._latencyStart = null;\n    }\n\n    this._clientID = result.client;\n    this._setStatus('connected');\n\n    if (this._refreshTimeout) {\n      clearTimeout(this._refreshTimeout);\n    }\n\n    if (result.expires) {\n      this._refreshTimeout = setTimeout(() => this._refresh(), this._getTTLMilliseconds(result.ttl));\n    }\n\n    this.startBatching();\n    this.startSubscribeBatching();\n    for (const channel in this._subs) {\n      if (this._subs.hasOwnProperty(channel)) {\n        const sub = this._subs[channel];\n        if (sub._shouldResubscribe()) {\n          this._subscribe(sub, wasReconnecting);\n        }\n      }\n    }\n    this.stopSubscribeBatching();\n    this.stopBatching();\n\n    this._startPing();\n\n    const ctx = {\n      client: result.client,\n      transport: this._transportName,\n      latency: this._latency\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n\n    this.emit('connect', ctx);\n\n    if (result.subs) {\n      this._processServerSubs(result.subs);\n    }\n  };\n\n  _processServerSubs(subs) {\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        const isResubscribe = this._serverSubs[channel] !== undefined;\n        let subCtx = {channel: channel, isResubscribe: isResubscribe};\n        subCtx = this._expandSubscribeContext(subCtx, sub);\n        this.emit('subscribe', subCtx);\n      }\n    }\n    for (const channel in subs) {\n      if (subs.hasOwnProperty(channel)) {\n        const sub = subs[channel];\n        if (sub.recovered) {\n          let pubs = sub.publications;\n          if (pubs && pubs.length > 0) {\n\n            // handle legacy order.\n            // TODO: remove as soon as Centrifuge v1 released.\n            if (pubs.length > 1 && (!pubs[0].offset || pubs[0].offset > pubs[1].offset)) {\n              pubs = pubs.reverse();\n            }\n\n            for (let i in pubs) {\n              if (pubs.hasOwnProperty(i)) {\n                this._handlePublication(channel, pubs[i]);\n              }\n            }\n          }\n        }\n        this._serverSubs[channel] = {\n          'seq': sub.seq,\n          'gen': sub.gen,\n          'offset': sub.offset,\n          'epoch': sub.epoch,\n          'recoverable': sub.recoverable\n        };\n      }\n    }\n  };\n\n  _stopPing() {\n    if (this._pongTimeout !== null) {\n      clearTimeout(this._pongTimeout);\n      this._pongTimeout = null;\n    }\n    if (this._pingTimeout !== null) {\n      clearTimeout(this._pingTimeout);\n      this._pingTimeout = null;\n    }\n  };\n\n  _startPing() {\n    if (this._config.ping !== true || this._config.pingInterval <= 0) {\n      return;\n    }\n    if (!this.isConnected()) {\n      return;\n    }\n\n    this._pingTimeout = setTimeout(() => {\n      if (!this.isConnected()) {\n        this._stopPing();\n        return;\n      }\n      this.ping();\n      this._pongTimeout = setTimeout(() => {\n        this._disconnect('no ping', true);\n      }, this._config.pongWaitTimeout);\n    }, this._config.pingInterval);\n  };\n\n  _restartPing() {\n    this._stopPing();\n    this._startPing();\n  };\n\n  _subscribeError(channel, error) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    if (error.code === 0 && error.message === _errorTimeout) { // client side timeout.\n      this._disconnect('timeout', true);\n      return;\n    }\n    sub._setSubscribeError(error);\n  };\n\n  _expandSubscribeContext(ctx, result) {\n    let recovered = false;\n    if ('recovered' in result) {\n      recovered = result.recovered;\n    }\n    ctx.recovered = recovered;\n\n    let positioned = false;\n    if ('positioned' in result) {\n      positioned = result.positioned;\n    }\n    let epoch = '';\n    if ('epoch' in result) {\n      epoch = result.epoch;\n    }\n    let offset = 0;\n    if ('offset' in result) {\n      offset = result.offset;\n    }\n    if (positioned) {\n      ctx.streamPosition = {\n        'offset': offset,\n        'epoch': epoch\n      };\n    };\n    if (result.data) {\n      ctx.data = result.data;\n    }\n    return ctx;\n  }\n\n  _subscribeResponse(channel, isRecover, result) {\n    const sub = this._getSub(channel);\n    if (!sub) {\n      return;\n    }\n    if (!sub._isSubscribing()) {\n      return;\n    }\n    sub._setSubscribeSuccess(result);\n\n    let pubs = result.publications;\n    if (pubs && pubs.length > 0) {\n      if (pubs.length >= 2 && !pubs[0].offset && !pubs[1].offset) {\n        // handle legacy order.\n        pubs = pubs.reverse();\n      }\n      for (let i in pubs) {\n        if (pubs.hasOwnProperty(i)) {\n          this._handlePublication(channel, pubs[i]);\n        }\n      }\n    }\n\n    if (result.recoverable && (!isRecover || !result.recovered)) {\n      this._lastSeq[channel] = result.seq || 0;\n      this._lastGen[channel] = result.gen || 0;\n      this._lastOffset[channel] = result.offset || 0;\n    }\n\n    this._lastEpoch[channel] = result.epoch || '';\n\n    if (result.recoverable) {\n      sub._recoverable = true;\n    }\n\n    if (result.expires === true) {\n      let subRefreshTimeout = setTimeout(() => this._subRefresh(channel), this._getTTLMilliseconds(result.ttl));\n      this._subRefreshTimeouts[channel] = subRefreshTimeout;\n    }\n  };\n\n  _handleReply(reply, next) {\n    const id = reply.id;\n    const result = reply.result;\n\n    if (!(id in this._callbacks)) {\n      next();\n      return;\n    }\n    const callbacks = this._callbacks[id];\n    clearTimeout(this._callbacks[id].timeout);\n    delete this._callbacks[id];\n\n    if (!errorExists(reply)) {\n      const callback = callbacks.callback;\n      if (!callback) {\n        return;\n      }\n      callback({result, next});\n    } else {\n      const errback = callbacks.errback;\n      if (!errback) {\n        next();\n        return;\n      }\n      const error = reply.error;\n      errback({error, next});\n    }\n  }\n\n  _handleJoin(channel, join) {\n    const ctx = {'info': join.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('join', ctx);\n      }\n      return;\n    }\n    sub.emit('join', ctx);\n  };\n\n  _handleLeave(channel, leave) {\n    const ctx = {'info': leave.info};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        ctx.channel = channel;\n        this.emit('leave', ctx);\n      }\n      return;\n    }\n    sub.emit('leave', ctx);\n  };\n\n  _handleUnsub(channel, unsub) {\n    const ctx = {};\n    const sub = this._getSub(channel);\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        delete this._serverSubs[channel];\n        ctx.channel = channel;\n        this.emit('unsubscribe', ctx);\n      }\n      return;\n    }\n    sub.unsubscribe();\n    if (unsub.resubscribe === true) {\n      sub.subscribe();\n    }\n  };\n\n  _handleSub(channel, sub) {\n    this._serverSubs[channel] = {\n      'seq': sub.seq,\n      'gen': sub.gen,\n      'offset': sub.offset,\n      'epoch': sub.epoch,\n      'recoverable': sub.recoverable\n    };\n    let ctx = {'channel': channel, isResubscribe: false};\n    ctx = this._expandSubscribeContext(ctx, sub);\n    this.emit('subscribe', ctx);\n  };\n\n  _handlePublication(channel, pub) {\n    const sub = this._getSub(channel);\n    const ctx = {\n      'data': pub.data,\n      'seq': pub.seq,\n      'gen': pub.gen,\n      'offset': pub.offset\n    };\n    if (pub.info) {\n      ctx.info = pub.info;\n    }\n    if (!sub) {\n      if (this._isServerSub(channel)) {\n        if (pub.seq !== undefined) {\n          this._serverSubs[channel].seq = pub.seq;\n        }\n        if (pub.gen !== undefined) {\n          this._serverSubs[channel].gen = pub.gen;\n        }\n        if (pub.offset !== undefined) {\n          this._serverSubs[channel].offset = pub.offset;\n        }\n        ctx.channel = channel;\n        this.emit('publish', ctx);\n      }\n      return;\n    }\n    if (pub.seq !== undefined) {\n      this._lastSeq[channel] = pub.seq;\n    }\n    if (pub.gen !== undefined) {\n      this._lastGen[channel] = pub.gen;\n    }\n    if (pub.offset !== undefined) {\n      this._lastOffset[channel] = pub.offset;\n    }\n    sub.emit('publish', ctx);\n  };\n\n  _handleMessage(message) {\n    this.emit('message', message.data);\n  };\n\n  _handlePush(data, next) {\n    const push = this._decoder.decodePush(data);\n    let type = 0;\n    if ('type' in push) {\n      type = push['type'];\n    }\n    const channel = push.channel;\n\n    if (type === this._pushType.PUBLICATION) {\n      const pub = this._decoder.decodePushData(this._pushType.PUBLICATION, push.data);\n      this._handlePublication(channel, pub);\n    } else if (type === this._pushType.MESSAGE) {\n      const message = this._decoder.decodePushData(this._pushType.MESSAGE, push.data);\n      this._handleMessage(message);\n    } else if (type === this._pushType.JOIN) {\n      const join = this._decoder.decodePushData(this._pushType.JOIN, push.data);\n      this._handleJoin(channel, join);\n    } else if (type === this._pushType.LEAVE) {\n      const leave = this._decoder.decodePushData(this._pushType.LEAVE, push.data);\n      this._handleLeave(channel, leave);\n    } else if (type === this._pushType.UNSUB) {\n      const unsub = this._decoder.decodePushData(this._pushType.UNSUB, push.data);\n      this._handleUnsub(channel, unsub);\n    } else if (type === this._pushType.SUB) {\n      const sub = this._decoder.decodePushData(this._pushType.SUB, push.data);\n      this._handleSub(channel, sub);\n    }\n    next();\n  }\n\n  _flush() {\n    const messages = this._messages.slice(0);\n    this._messages = [];\n    this._transportSend(messages);\n  };\n\n  _ping() {\n    const msg = {\n      method: this._methodType.PING\n    };\n    this._call(msg).then(resolveCtx => {\n      this._pingResponse(this._decoder.decodeCommandResult(this._methodType.PING, resolveCtx.result));\n      if (resolveCtx.next) {\n        resolveCtx.next();\n      }\n    }, rejectCtx => {\n      this._debug('ping error', rejectCtx.error);\n      if (rejectCtx.next) {\n        rejectCtx.next();\n      }\n    });\n  };\n\n  _pingResponse(result) {\n    if (!this.isConnected()) {\n      return;\n    }\n    this._stopPing();\n    this._startPing();\n  }\n\n  _getLastSeq(channel) {\n    const lastSeq = this._lastSeq[channel];\n    if (lastSeq) {\n      return lastSeq;\n    }\n    return 0;\n  };\n\n  _getLastOffset(channel) {\n    const lastOffset = this._lastOffset[channel];\n    if (lastOffset) {\n      return lastOffset;\n    }\n    return 0;\n  };\n\n  _getLastGen(channel) {\n    const lastGen = this._lastGen[channel];\n    if (lastGen) {\n      return lastGen;\n    }\n    return 0;\n  };\n\n  _getLastEpoch(channel) {\n    const lastEpoch = this._lastEpoch[channel];\n    if (lastEpoch) {\n      return lastEpoch;\n    }\n    return '';\n  };\n\n  _createErrorObject(message, code) {\n    const errObject = {\n      message: message,\n      code: code || 0\n    };\n\n    return errObject;\n  };\n\n  _registerCall(id, callback, errback) {\n    this._callbacks[id] = {\n      callback: callback,\n      errback: errback,\n      timeout: null\n    };\n    this._callbacks[id].timeout = setTimeout(() => {\n      delete this._callbacks[id];\n      if (isFunction(errback)) {\n        errback({error: this._createErrorObject(_errorTimeout)});\n      }\n    }, this._config.timeout);\n  };\n\n  _addMessage(message) {\n    let id = this._nextMessageId();\n    message.id = id;\n    if (this._isBatching === true) {\n      this._messages.push(message);\n    } else {\n      this._transportSend([message]);\n    }\n    return id;\n  };\n\n  isConnected() {\n    return this._isConnected();\n  }\n\n  connect() {\n    this._connect();\n  };\n\n  disconnect() {\n    this._disconnect('client', false);\n  };\n\n  ping() {\n    return this._ping();\n  }\n\n  startBatching() {\n    // start collecting messages without sending them to Centrifuge until flush\n    // method called\n    this._isBatching = true;\n  };\n\n  stopBatching() {\n    this._isBatching = false;\n    this._flush();\n  };\n\n  startSubscribeBatching() {\n    // start collecting private channels to create bulk authentication\n    // request to subscribeEndpoint when stopSubscribeBatching will be called\n    this._isSubscribeBatching = true;\n  };\n\n  stopSubscribeBatching() {\n    // create request to subscribeEndpoint with collected private channels\n    // to ask if this client can subscribe on each channel\n    this._isSubscribeBatching = false;\n    const authChannels = this._privateChannels;\n    this._privateChannels = {};\n\n    const channels = [];\n\n    for (const channel in authChannels) {\n      if (authChannels.hasOwnProperty(channel)) {\n        const sub = this._getSub(channel);\n        if (!sub) {\n          continue;\n        }\n        channels.push(channel);\n      }\n    }\n\n    if (channels.length === 0) {\n      this._debug('no private channels found, no need to make request');\n      return;\n    }\n\n    const data = {\n      client: this._clientID,\n      channels: channels\n    };\n\n    const clientID = this._clientID;\n    const xhrID = this._newXHRID();\n\n    const cb = (resp) => {\n      if (xhrID in this._xhrs) {\n        delete this._xhrs[xhrID];\n      }\n      if (this._clientID !== clientID) {\n        return;\n      }\n      if (resp.error || resp.status !== 200) {\n        this._debug('authorization request failed');\n        for (const i in channels) {\n          if (channels.hasOwnProperty(i)) {\n            const channel = channels[i];\n            this._subscribeError(channel, this._createErrorObject('authorization request failed'));\n          }\n        }\n        return;\n      }\n\n      let channelsData = {};\n      if (resp.data.channels) {\n        for (const i in resp.data.channels) {\n          const channelData = resp.data.channels[i];\n          if (!channelData.channel) {\n            continue;\n          }\n          channelsData[channelData.channel] = channelData.token;\n        }\n      }\n\n      // try to send all subscriptions in one request.\n      let batch = false;\n\n      if (!this._isBatching) {\n        this.startBatching();\n        batch = true;\n      }\n\n      for (const i in channels) {\n        if (channels.hasOwnProperty(i)) {\n          const channel = channels[i];\n          const token = channelsData[channel];\n\n          if (!token) {\n            // subscription:error\n            this._subscribeError(channel, this._createErrorObject('permission denied', 103));\n            continue;\n          } else {\n            const msg = {\n              method: this._methodType.SUBSCRIBE,\n              params: {\n                channel: channel,\n                token: token\n              }\n            };\n\n            const sub = this._getSub(channel);\n            if (sub === null) {\n              continue;\n            }\n\n            const recover = sub._needRecover();\n\n            if (recover === true) {\n              msg.params.recover = true;\n              const seq = this._getLastSeq(channel);\n              const gen = this._getLastGen(channel);\n              if (seq || gen) {\n                if (seq) {\n                  msg.params.seq = seq;\n                }\n                if (gen) {\n                  msg.params.gen = gen;\n                }\n              } else {\n                const offset = this._getLastOffset(channel);\n                if (offset) {\n                  msg.params.offset = offset;\n                }\n              }\n              const epoch = this._getLastEpoch(channel);\n              if (epoch) {\n                msg.params.epoch = epoch;\n              }\n            }\n            this._call(msg).then(resolveCtx => {\n              this._subscribeResponse(\n                channel,\n                recover,\n                this._decoder.decodeCommandResult(this._methodType.SUBSCRIBE, resolveCtx.result)\n              );\n              if (resolveCtx.next) {\n                resolveCtx.next();\n              }\n            }, rejectCtx => {\n              this._subscribeError(channel, rejectCtx.error);\n              if (rejectCtx.next) {\n                rejectCtx.next();\n              }\n            });\n          }\n        }\n      }\n\n      if (batch) {\n        this.stopBatching();\n      }\n\n    };\n\n    if (this._config.onPrivateSubscribe !== null) {\n      this._config.onPrivateSubscribe({\n        data: data\n      }, cb);\n    } else {\n      const xhr = this._ajax(\n        this._config.subscribeEndpoint, this._config.subscribeParams, this._config.subscribeHeaders, data, cb);\n      this._xhrs[xhrID] = xhr;\n    }\n  };\n\n  subscribe(channel, events) {\n    const currentSub = this._getSub(channel);\n    if (currentSub !== null) {\n      currentSub._setEvents(events);\n      if (currentSub._isUnsubscribed()) {\n        currentSub.subscribe();\n      }\n      return currentSub;\n    }\n    const sub = new Subscription(this, channel, events);\n    this._subs[channel] = sub;\n    sub.subscribe();\n    return sub;\n  };\n}\n","import {Centrifuge} from './centrifuge.js';\nexport default Centrifuge;\n","export const JsonMethodType = {\n  CONNECT: 0,\n  SUBSCRIBE: 1,\n  UNSUBSCRIBE: 2,\n  PUBLISH: 3,\n  PRESENCE: 4,\n  PRESENCE_STATS: 5,\n  HISTORY: 6,\n  PING: 7,\n  SEND: 8,\n  RPC: 9,\n  REFRESH: 10,\n  SUB_REFRESH: 11\n};\n\nexport const JsonPushType = {\n  PUBLICATION: 0,\n  JOIN: 1,\n  LEAVE: 2,\n  UNSUB: 3,\n  MESSAGE: 4,\n  SUB: 5\n};\n\nexport class JsonEncoder {\n  encodeCommands(commands) {\n    return commands.map(c => JSON.stringify(c)).join('\\n');\n  }\n}\n\nexport class JsonDecoder {\n  decodeReplies(data) {\n    return data.split('\\n').filter(r => r !== '').map(r => JSON.parse(r));\n  }\n\n  decodeCommandResult(methodType, data) {\n    return data;\n  }\n\n  decodePush(data) {\n    return data;\n  }\n\n  decodePushData(pushType, data) {\n    return data;\n  }\n}\n\n","import EventEmitter from 'events';\n\nimport {\n  isFunction\n} from './utils';\n\nconst _STATE_NEW = 0;\nconst _STATE_SUBSCRIBING = 1;\nconst _STATE_SUCCESS = 2;\nconst _STATE_ERROR = 3;\nconst _STATE_UNSUBSCRIBED = 4;\n\nexport default class Subscription extends EventEmitter {\n  constructor(centrifuge, channel, events) {\n    super();\n    this.channel = channel;\n    this._centrifuge = centrifuge;\n    this._status = _STATE_NEW;\n    this._error = null;\n    this._isResubscribe = false;\n    this._ready = false;\n    this._subscriptionPromise = null;\n    this._noResubscribe = false;\n    this._recoverable = false;\n    this._recover = false;\n    this._setEvents(events);\n    this._initializePromise();\n    this._promises = {};\n    this._promiseId = 0;\n    this.on('error', function (errContext) {\n      this._centrifuge._debug('subscription error', errContext);\n    });\n  }\n\n  _nextPromiseId() {\n    return ++this._promiseId;\n  }\n\n  _initializePromise() {\n    // this helps us to wait until subscription will successfully\n    // subscribe and call actions such as presence, history etc in\n    // synchronous way.\n    this._ready = false;\n\n    this._subscriptionPromise = new Promise((resolve, reject) => {\n      this._resolve = value => {\n        this._ready = true;\n        resolve(value);\n      };\n      this._reject = err => {\n        this._ready = true;\n        reject(err);\n      };\n    }).then(function () {}, function () {});\n  };\n\n  _needRecover() {\n    return this._recoverable === true && this._recover === true;\n  };\n\n  _setEvents(events) {\n    if (!events) {\n      return;\n    }\n    if (isFunction(events)) {\n      // events is just a function to handle publication received from channel.\n      this.on('publish', events);\n    } else if (Object.prototype.toString.call(events) === Object.prototype.toString.call({})) {\n      const knownEvents = ['publish', 'join', 'leave', 'unsubscribe', 'subscribe', 'error'];\n      for (let i = 0, l = knownEvents.length; i < l; i++) {\n        const ev = knownEvents[i];\n        if (ev in events) {\n          this.on(ev, events[ev]);\n        }\n      }\n    }\n  };\n\n  _isNew() {\n    return this._status === _STATE_NEW;\n  };\n\n  _isUnsubscribed() {\n    return this._status === _STATE_UNSUBSCRIBED;\n  };\n\n  _isSubscribing() {\n    return this._status === _STATE_SUBSCRIBING;\n  };\n\n  _isReady() {\n    return this._status === _STATE_SUCCESS || this._status === _STATE_ERROR;\n  };\n\n  _isSuccess() {\n    return this._status === _STATE_SUCCESS;\n  };\n\n  _isError() {\n    return this._status === _STATE_ERROR;\n  };\n\n  _setNew() {\n    this._status = _STATE_NEW;\n  };\n\n  _setSubscribing(isResubscribe) {\n    this._isResubscribe = isResubscribe || false;\n    if (this._ready === true) {\n      // new promise for this subscription\n      this._initializePromise();\n    }\n    this._status = _STATE_SUBSCRIBING;\n  };\n\n  _setSubscribeSuccess(subscribeResult) {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._status = _STATE_SUCCESS;\n    const successContext = this._getSubscribeSuccessContext(subscribeResult);\n    this._recover = false;\n    this.emit('subscribe', successContext);\n    this._resolve(successContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].resolve();\n      delete this._promises[id];\n    }\n  };\n\n  _setSubscribeError(err) {\n    if (this._status === _STATE_ERROR) {\n      return;\n    }\n    this._status = _STATE_ERROR;\n    this._error = err;\n    const errContext = this._getSubscribeErrorContext();\n    this.emit('error', errContext);\n    this._reject(errContext);\n    for (const id in this._promises) {\n      clearTimeout(this._promises[id].timeout);\n      this._promises[id].reject(err);\n      delete this._promises[id];\n    }\n  };\n\n  _triggerUnsubscribe() {\n    this.emit('unsubscribe', {\n      channel: this.channel\n    });\n  };\n\n  _setUnsubscribed(noResubscribe) {\n    this._centrifuge._clearSubRefreshTimeout(this.channel);\n    if (this._status === _STATE_UNSUBSCRIBED) {\n      return;\n    }\n    const needTrigger = this._status === _STATE_SUCCESS;\n    this._status = _STATE_UNSUBSCRIBED;\n    if (noResubscribe === true) {\n      this._recover = false;\n      this._noResubscribe = true;\n      delete this._centrifuge._lastSeq[this.channel];\n      delete this._centrifuge._lastGen[this.channel];\n      delete this._centrifuge._lastEpoch[this.channel];\n    }\n    if (needTrigger) {\n      this._triggerUnsubscribe();\n    }\n  };\n\n  _shouldResubscribe() {\n    return !this._noResubscribe;\n  };\n\n  _getSubscribeSuccessContext(subscribeResult) {\n    let ctx = {\n      channel: this.channel,\n      isResubscribe: this._isResubscribe\n    };\n    if (subscribeResult) {\n      // subscribeResult not available when called from Subscription.ready method at the moment.\n      ctx = this._centrifuge._expandSubscribeContext(ctx, subscribeResult);\n    }\n    return ctx;\n  };\n\n  _getSubscribeErrorContext() {\n    const subscribeErrorContext = this._error;\n    subscribeErrorContext.channel = this.channel;\n    subscribeErrorContext.isResubscribe = this._isResubscribe;\n    return subscribeErrorContext;\n  };\n\n  ready(callback, errback) {\n    if (this._ready) {\n      if (this._isSuccess()) {\n        callback(this._getSubscribeSuccessContext());\n      } else {\n        errback(this._getSubscribeErrorContext());\n      }\n    }\n  };\n\n  subscribe() {\n    if (this._status === _STATE_SUCCESS) {\n      return;\n    }\n    this._noResubscribe = false;\n    this._centrifuge._subscribe(this);\n  };\n\n  unsubscribe() {\n    this._setUnsubscribed(true);\n    this._centrifuge._unsubscribe(this);\n  };\n\n  _methodCall() {\n    if (this._isSuccess()) {\n      return Promise.resolve();\n    } else if (this._isError()) {\n      return Promise.reject(this._error);\n    }\n    let subPromise = new Promise((res, rej) => {\n      const timeout = setTimeout(function () {\n        rej({'code': 0, 'message': 'timeout'});\n      }, this._centrifuge._config.timeout);\n      this._promises[this._nextPromiseId()] = {\n        timeout: timeout,\n        resolve: res,\n        reject: rej\n      };\n    });\n    return subPromise;\n  }\n\n  publish(data) {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.publish(self.channel, data);\n    });\n  };\n\n  presence() {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presence(self.channel);\n    });\n  };\n\n  presenceStats() {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.presenceStats(self.channel);\n    });\n  };\n\n  history(options) {\n    const self = this;\n    return this._methodCall().then(function () {\n      return self._centrifuge.history(self.channel, options);\n    });\n  };\n}\n","export function startsWith(value, prefix) {\n  return value.lastIndexOf(prefix, 0) === 0;\n};\n\nexport function isFunction(value) {\n  if (value === undefined || value === null) {\n    return false;\n  }\n  return typeof value === 'function';\n};\n\nexport function log(level, args) {\n  if (global.console) {\n    const logger = global.console[level];\n\n    if (isFunction(logger)) {\n      logger.apply(global.console, args);\n    }\n  }\n};\n\nexport function backoff(step, min, max) {\n  const jitter = 0.5 * Math.random();\n  const interval = Math.min(max, min * Math.pow(2, step + 1));\n\n  return Math.floor((1 - jitter) * interval);\n};\n\nexport function errorExists(data) {\n  return 'error' in data && data.error !== null;\n};\n\nexport function extend(a, b) {\n  for (const key in b) {\n    if (b.hasOwnProperty(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(579);\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}